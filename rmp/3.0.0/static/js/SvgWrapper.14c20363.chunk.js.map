{"version":3,"file":"static/js/SvgWrapper.14c20363.chunk.js","mappings":"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","sources":["components/svgs/lines/line-wrapper.tsx","util/reconcile.ts","util/process-elements.ts","components/svg-canvas-graph.tsx","components/svg-wrapper.tsx","util/hooks.ts","util/helpers.ts","../node_modules/react-use-event-hook/src/useEvent.ts","../node_modules/@chakra-ui/layout/dist/chunk-HUQHYERK.mjs"],"sourcesContent":["import React from 'react';\nimport { ExternalLineStyleAttributes } from '../../../constants/lines';\nimport { LineWrapperComponentProps, LineStyleComponentProps } from '../../../constants/lines';\nimport { linePaths, lineStyles } from './lines';\n\nconst LineWrapper = (props: LineWrapperComponentProps) => {\n    const { id, type, attrs, styleType, styleAttrs = lineStyles[styleType].defaultAttrs, newLine, handleClick } = props;\n    const { x1, y1, x2, y2 } = props;\n\n    const [path, setPath] = React.useState('M 0,0 L 0,0' as `${'m' | 'M'}${string}`);\n    React.useEffect(() => {\n        setPath(linePaths[type].generatePath(x1, x2, y1, y2, attrs as any));\n    }, [type, JSON.stringify(attrs), x1, x2, y1, y2]);\n\n    // HELP NEEDED: Why component is not this type?\n    const StyleComponent = lineStyles[styleType].component as <\n        T extends NonNullable<ExternalLineStyleAttributes[keyof ExternalLineStyleAttributes]>\n    >(\n        props: LineStyleComponentProps<T>\n    ) => JSX.Element;\n\n    return React.useMemo(\n        () => (\n            <StyleComponent\n                id={id}\n                type={type}\n                path={path}\n                styleAttrs={styleAttrs}\n                newLine={newLine}\n                handleClick={handleClick}\n            />\n        ),\n        [id, type, path, styleType, JSON.stringify(styleAttrs), newLine, handleClick]\n    );\n};\n\nexport default LineWrapper;\n","import { MultiDirectedGraph } from 'graphology';\nimport { LineId, NodeAttributes, EdgeAttributes, GraphAttributes } from '../constants/constants';\nimport { linePaths } from '../components/svgs/lines/lines';\n\n/**\n * Only lines have a reconcileId will be considered.\n */\nconst getAllLinesNeedToReconcile = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    const linesNeedToReconcile = graph.filterDirectedEdges(\n        (edge, attr, source, target, sourceAttr, targetAttr, undirected) =>\n            edge.startsWith('line') && attr.reconcileId !== ''\n    ) as LineId[];\n\n    const lineGroupToReconcile: { [reconcileId: string]: LineId[] } = {};\n    for (const lineNeedReconcile of linesNeedToReconcile) {\n        const reconcileId = graph.getEdgeAttribute(lineNeedReconcile, 'reconcileId');\n        if (reconcileId in lineGroupToReconcile) lineGroupToReconcile[reconcileId].push(lineNeedReconcile);\n        else lineGroupToReconcile[reconcileId] = [lineNeedReconcile];\n    }\n\n    return lineGroupToReconcile;\n};\n\n/**\n * Reconcile lines to a single path.\n *\n * It will try to find a path from one source to one target if\n * the lines are set correctly. All the lines need to implement\n * the generatePath function.\n */\nconst reconcileLines = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    const lineGroupToReconcile = getAllLinesNeedToReconcile(graph);\n    // console.log(lineGroupToReconcile);\n\n    const allReconciledLines: LineId[][] = [];\n    const danglingLines: LineId[] = [];\n    Object.values(lineGroupToReconcile).forEach(linesNeedToReconcile => {\n        // it is not possible to reconcile a single line\n        if (linesNeedToReconcile.length === 1) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // all the lines in linesNeedToReconcile should be the same type and style\n        const type = graph.getEdgeAttribute(linesNeedToReconcile.at(0), 'type');\n        if (!linesNeedToReconcile.every(line => graph.getEdgeAttribute(line, 'type') === type)) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n        const style = graph.getEdgeAttribute(linesNeedToReconcile.at(0), 'style');\n        if (!linesNeedToReconcile.every(line => graph.getEdgeAttribute(line, 'style') === style)) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // find the source and target for the whole line\n        const count: { [node: string]: number } = {}; // count on every nodes' occurrence\n        const sources: Set<string> = new Set();\n        const targets: Set<string> = new Set();\n        const extremities = Object.fromEntries(\n            linesNeedToReconcile.map(line => {\n                const [source, target] = graph.extremities(line);\n                count[source] = (count[source] ?? 0) + 1;\n                count[target] = (count[target] ?? 0) + 1;\n                sources.add(source);\n                targets.add(target);\n                return [source, [line, target] as [LineId, string]];\n            })\n        );\n\n        // source need to be the node appear only once in all sources and targets\n        // and there must be only one.\n        const source_ = Array.from(sources).filter(s => count[s] === 1);\n        const target_ = Array.from(targets).filter(t => count[t] === 1);\n        // console.log(source_, target_, count);\n        if (source_.length !== 1 || target_.length !== 1) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n        const source = source_[0];\n        const target = target_[0];\n        if (source === target) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // start from source, find each consecutive line\n        const reconciledLines: LineId[] = [extremities[source][0]];\n        let currentNode = extremities[source][1];\n        for (let i = 1; i < linesNeedToReconcile.length; i = i + 1) {\n            const currentTarget = extremities[currentNode]?.at(1);\n            // console.log(currentNode, extremities[currentNode]?.at(0), currentTarget);\n            if (!currentTarget) {\n                danglingLines.push(...linesNeedToReconcile);\n                return;\n            }\n\n            reconciledLines.push(extremities[currentNode][0]);\n            currentNode = currentTarget;\n        }\n        // console.log(currentNode, reconciledLines);\n        if (currentNode !== target || reconciledLines.length !== linesNeedToReconcile.length) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n        allReconciledLines.push(reconciledLines);\n    });\n\n    return { allReconciledLines, danglingLines };\n};\n\nexport default reconcileLines;\n\n/**\n * Call each lines' `generatePath` and merge all the paths to a single path.\n */\nexport const generateReconciledPath = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>,\n    reconciledLines: LineId[]\n) => {\n    if (!reconciledLines.every(line => graph.hasEdge(line))) return undefined;\n\n    // call each line's generatePath to generate its own path\n    const paths = reconciledLines.map(line => {\n        const [source, target] = graph.extremities(line);\n        const sourceAttr = graph.getNodeAttributes(source);\n        const targetAttr = graph.getNodeAttributes(target);\n        const type = graph.getEdgeAttribute(line, 'type');\n        const attr = graph.getEdgeAttribute(line, type) ?? linePaths[type].defaultAttrs;\n        // @ts-ignore-error\n        return linePaths[type].generatePath(sourceAttr.x, targetAttr.x, sourceAttr.y, targetAttr.y, attr);\n    });\n\n    // merge paths to one\n    let path = `${paths[0]} `;\n    for (let i = 1; i < reconciledLines.length; i = i + 1) {\n        path += paths[i].replace(/M\\s*-?\\d+(\\.\\d+)?(\\s*|,)-?\\d+(\\.*\\d+)?\\s*/i, '');\n    }\n    // console.log(reconciledLines, paths, path);\n\n    return path as `${'m' | 'M'}${string}`;\n};\n","import { MultiDirectedGraph } from 'graphology';\nimport { StnId, LineId, MiscNodeId, NodeAttributes, EdgeAttributes, GraphAttributes } from '../constants/constants';\nimport { StationType } from '../constants/stations';\nimport { MiscNodeType } from '../constants/nodes';\nimport {\n    ExternalLinePathAttributes,\n    ExternalLineStyleAttributes,\n    LineStyleType,\n    LinePathType,\n} from '../constants/lines';\n\n/**\n * This file contains helper methods to extract stations/miscNodes/lines\n * from MultiDirectedGraph and return elements that svg-canvas can directly\n * pass them to corresponding stations/miscNodes/lines components.\n */\n\ntype StationElem = NodeAttributes & { node: StnId; type: StationType };\nexport const getStations = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>\n): StationElem[] =>\n    graph\n        .filterNodes((node, attr) => node.startsWith('stn'))\n        .map(node => [node, graph.getNodeAttributes(node)] as [StnId, NodeAttributes])\n        .filter(([node, attr]) => attr.visible)\n        .sort((a, b) => a[1].zIndex - b[1].zIndex)\n        .map(([node, attr]) => ({\n            node: node as StnId,\n            visible: attr.visible,\n            zIndex: attr.zIndex,\n            x: attr.x,\n            y: attr.y,\n            type: attr.type as StationType,\n            [attr.type]: attr[attr.type],\n        }));\n\ntype LineElem = {\n    edge: LineId;\n    x1: number;\n    x2: number;\n    y1: number;\n    y2: number;\n    type: LinePathType;\n    attr: ExternalLinePathAttributes[keyof ExternalLinePathAttributes];\n    style: LineStyleType;\n    styleAttr: ExternalLineStyleAttributes[keyof ExternalLineStyleAttributes];\n};\nexport const getLines = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>): LineElem[] =>\n    graph\n        .filterDirectedEdges(\n            (edge, attr, source, target, sourceAttr, targetAttr, undirected) =>\n                edge.startsWith('line') && attr.visible && attr.reconcileId === ''\n        )\n        .sort((a, b) => graph.getEdgeAttribute(a, 'zIndex') - graph.getEdgeAttribute(b, 'zIndex'))\n        .map(edge => {\n            const type = graph.getEdgeAttribute(edge, 'type') as LinePathType;\n            const attr = graph.getEdgeAttribute(\n                edge,\n                type\n            ) as ExternalLinePathAttributes[keyof ExternalLinePathAttributes];\n            const style = graph.getEdgeAttribute(edge, 'style') as LineStyleType;\n            const styleAttr = graph.getEdgeAttribute(\n                edge,\n                style\n            ) as ExternalLineStyleAttributes[keyof ExternalLineStyleAttributes];\n            const [source, target] = graph.extremities(edge);\n            const sourceAttr = graph.getNodeAttributes(source);\n            const targetAttr = graph.getNodeAttributes(target);\n            return {\n                edge: edge as LineId,\n                x1: sourceAttr.x,\n                y1: sourceAttr.y,\n                x2: targetAttr.x,\n                y2: targetAttr.y,\n                type,\n                attr,\n                style,\n                styleAttr,\n            };\n        });\n\ntype MiscNodeElem = NodeAttributes & { node: MiscNodeId; type: MiscNodeType };\nexport const getMiscNodes = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>\n): MiscNodeElem[] =>\n    graph\n        .filterNodes((node, attr) => node.startsWith('misc_node'))\n        .map(node => [node, graph.getNodeAttributes(node)] as [MiscNodeId, NodeAttributes])\n        .filter(([node, attr]) => attr.visible)\n        .sort((a, b) => a[1].zIndex - b[1].zIndex)\n        .map(([node, attr]) => ({\n            node,\n            visible: attr.visible,\n            zIndex: attr.zIndex,\n            x: attr.x,\n            y: attr.y,\n            type: attr.type as MiscNodeType,\n            [attr.type]: attr[attr.type],\n        }));\n","import React from 'react';\nimport useEvent from 'react-use-event-hook';\nimport { nanoid } from 'nanoid';\nimport rmgRuntime from '@railmapgen/rmg-runtime';\nimport { useRootDispatch, useRootSelector } from '../redux';\nimport { saveGraph } from '../redux/param/param-slice';\nimport {\n    setActive,\n    addSelected,\n    setRefreshNodes,\n    setRefreshEdges,\n    setMode,\n    clearSelected,\n} from '../redux/runtime/runtime-slice';\nimport { StnId, LineId, MiscNodeId, Events } from '../constants/constants';\nimport { LineStyleType, LinePathType, ExternalLineStyleAttributes, LineStyleComponentProps } from '../constants/lines';\nimport allStations from './svgs/stations/stations';\nimport { linePaths, lineStyles } from './svgs/lines/lines';\nimport LineWrapper from './svgs/lines/line-wrapper';\nimport miscNodes from './svgs/nodes/misc-nodes';\nimport { getMousePosition, roundToNearestN } from '../util/helpers';\nimport reconcileLines, { generateReconciledPath } from '../util/reconcile';\nimport { getStations, getMiscNodes, getLines } from '../util/process-elements';\n\nconst SvgCanvas = () => {\n    const dispatch = useRootDispatch();\n    const graph = React.useRef(window.graph);\n    const {\n        telemetry: { project: isAllowProjectTelemetry },\n    } = useRootSelector(state => state.app);\n    const { svgViewBoxZoom } = useRootSelector(state => state.param);\n    const {\n        selected,\n        refresh: { nodes: refreshNodes, edges: refreshEdges },\n        mode,\n        active,\n        keepLastPath,\n        theme,\n    } = useRootSelector(state => state.runtime);\n\n    // the position of pointer down\n    const [offset, setOffset] = React.useState({ x: 0, y: 0 });\n    // the position of pointer move\n    const [movingPosition, setMovingPosition] = React.useState({ x: 0, y: 0 });\n\n    const handlePointerDown = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        const el = e.currentTarget;\n        const { x, y } = getMousePosition(e);\n        el.setPointerCapture(e.pointerId);\n\n        setOffset({ x, y });\n\n        dispatch(setActive(node));\n        // details panel only, remove all if this is not a multiple selection\n        if (!e.shiftKey && selected.length <= 1) dispatch(clearSelected());\n        dispatch(addSelected(node)); // details panel only\n        // console.log('down ', graph.current.getNodeAttributes(node));\n    });\n    const handlePointerMove = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        const { x, y } = getMousePosition(e);\n\n        if (mode === 'free' && active === node) {\n            selected.forEach(s => {\n                graph.current.updateNodeAttributes(s, attr => ({\n                    ...attr,\n                    x: roundToNearestN(attr.x - ((offset.x - x) * svgViewBoxZoom) / 100, e.altKey ? 1 : 5),\n                    y: roundToNearestN(attr.y - ((offset.y - y) * svgViewBoxZoom) / 100, e.altKey ? 1 : 5),\n                }));\n            });\n            dispatch(setRefreshNodes());\n            dispatch(setRefreshEdges());\n            // console.log('move ', graph.current.getNodeAttributes(node));\n        } else if (mode.startsWith('line')) {\n            setMovingPosition({\n                x: ((offset.x - x) * svgViewBoxZoom) / 100,\n                y: ((offset.y - y) * svgViewBoxZoom) / 100,\n            });\n        }\n    });\n    const handlePointerUp = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        if (mode.startsWith('line') || mode.startsWith('misc-edge')) {\n            if (!keepLastPath) dispatch(setMode('free'));\n\n            const prefixes = ['stn_core_', 'virtual_circle_'];\n            prefixes.forEach(prefix => {\n                const elems = document.elementsFromPoint(e.clientX, e.clientY);\n                const id = elems[0].attributes?.getNamedItem('id')?.value;\n                if (id?.startsWith(prefix)) {\n                    const type = mode.slice(5) as LinePathType;\n                    const newLineId = `line_${nanoid(10)}`;\n                    graph.current.addDirectedEdgeWithKey(newLineId, active, id.slice(prefix.length), {\n                        visible: true,\n                        zIndex: 0,\n                        type,\n                        // deep copy to prevent mutual reference\n                        [type]: JSON.parse(JSON.stringify(linePaths[type].defaultAttrs)),\n                        style: LineStyleType.SingleColor,\n                        [LineStyleType.SingleColor]: { color: theme },\n                        reconcileId: '',\n                    });\n                    if (isAllowProjectTelemetry) rmgRuntime.event(Events.ADD_LINE, { type });\n                }\n            });\n            dispatch(setRefreshEdges());\n            dispatch(saveGraph(graph.current.export()));\n        } else if (mode === 'free') {\n            if (active) {\n                // the node is pointed down before\n                // check the offset and if it's not 0, it must be a click not move\n                const { x, y } = getMousePosition(e);\n                if (offset.x - x === 0 && offset.y - y === 0) {\n                    // display the details of current node on click\n                    dispatch(addSelected(node));\n                } else {\n                    // its a moving node operation, save the final coordinate\n                    dispatch(saveGraph(graph.current.export()));\n                }\n            } else {\n                // the node is just placed and should not trigger any save, only display the details\n                dispatch(addSelected(node));\n            }\n        }\n        dispatch(setActive(undefined));\n        // console.log('up ', graph.current.getNodeAttributes(node));\n    });\n    const handleEdgeClick = useEvent((edge: LineId, e: React.MouseEvent<SVGPathElement, MouseEvent>) => {\n        dispatch(clearSelected());\n        dispatch(addSelected(edge));\n    });\n\n    // These are elements that the svg draws from.\n    // They are updated by the refresh triggers in the runtime state.\n    const [stations, setStations] = React.useState(getStations(graph.current));\n    const [nodes, setNodes] = React.useState(getMiscNodes(graph.current));\n    const [lines, setLines] = React.useState(getLines(graph.current));\n    const [reconciledLines, setReconciledLines] = React.useState([] as LineId[][]);\n    const [danglingLines, setDanglingLines] = React.useState([] as LineId[]);\n    React.useEffect(() => {\n        setStations(getStations(graph.current));\n        setNodes(getMiscNodes(graph.current));\n    }, [refreshNodes]);\n    React.useEffect(() => {\n        setLines(getLines(graph.current));\n        const { allReconciledLines, danglingLines } = reconcileLines(graph.current);\n        setReconciledLines(allReconciledLines);\n        setDanglingLines(danglingLines);\n    }, []);\n    React.useEffect(() => {\n        setLines(getLines(graph.current));\n        const { allReconciledLines, danglingLines } = reconcileLines(graph.current);\n        setReconciledLines(allReconciledLines);\n        setDanglingLines(danglingLines);\n    }, [refreshEdges]);\n\n    return (\n        <>\n            {danglingLines.map(edge => {\n                const [source, target] = graph.current.extremities(edge);\n                const sourceAttr = graph.current.getNodeAttributes(source);\n                const targetAttr = graph.current.getNodeAttributes(target);\n                return (\n                    <LineWrapper\n                        id={edge}\n                        key={edge}\n                        x1={sourceAttr.x}\n                        y1={sourceAttr.y}\n                        x2={targetAttr.x}\n                        y2={targetAttr.y}\n                        newLine={false}\n                        type={LinePathType.Simple}\n                        attrs={linePaths[LinePathType.Simple].defaultAttrs}\n                        styleType={LineStyleType.SingleColor}\n                        styleAttrs={{ color: ['', '', '#c0c0c0', '#fff'] }}\n                        handleClick={handleEdgeClick}\n                    />\n                );\n            })}\n            {reconciledLines.map(reconciledLine => {\n                const path = generateReconciledPath(graph.current, reconciledLine);\n                if (!path) return <></>;\n\n                const id = reconciledLine.at(0)!;\n                const type = graph.current.getEdgeAttribute(id, 'type');\n                const style = graph.current.getEdgeAttribute(id, 'style');\n                const styleAttrs = graph.current.getEdgeAttribute(id, style) as NonNullable<\n                    ExternalLineStyleAttributes[keyof ExternalLineStyleAttributes]\n                >;\n                const StyleComponent = lineStyles[style].component as <\n                    T extends NonNullable<ExternalLineStyleAttributes[keyof ExternalLineStyleAttributes]>\n                >(\n                    props: LineStyleComponentProps<T>\n                ) => JSX.Element;\n\n                return (\n                    <StyleComponent\n                        id={id}\n                        key={id}\n                        type={type}\n                        path={path}\n                        styleAttrs={styleAttrs}\n                        newLine={false}\n                        handleClick={handleEdgeClick}\n                    />\n                );\n            })}\n            {lines.map(({ edge, x1, y1, x2, y2, type, attr, style, styleAttr }) => {\n                return (\n                    <LineWrapper\n                        id={edge}\n                        key={edge}\n                        x1={x1}\n                        y1={y1}\n                        x2={x2}\n                        y2={y2}\n                        newLine={false}\n                        type={type}\n                        attrs={attr}\n                        styleType={style}\n                        styleAttrs={styleAttr}\n                        handleClick={handleEdgeClick}\n                    />\n                );\n            })}\n            {nodes.map(n => {\n                const { node, x, y, type } = n;\n                const MiscNodeComponent = miscNodes[type].component;\n                return (\n                    <MiscNodeComponent\n                        id={node}\n                        key={node}\n                        x={x}\n                        y={y}\n                        // @ts-expect-error\n                        attrs={n[type]}\n                        handlePointerDown={handlePointerDown}\n                        handlePointerMove={handlePointerMove}\n                        handlePointerUp={handlePointerUp}\n                    />\n                );\n            })}\n            {stations.map(station => {\n                const { node, x, y, type } = station;\n                const StationComponent = allStations[type].component;\n                return (\n                    <StationComponent\n                        id={node}\n                        key={node}\n                        x={x}\n                        y={y}\n                        attrs={{ [type]: station[type] }}\n                        handlePointerDown={handlePointerDown}\n                        handlePointerMove={handlePointerMove}\n                        handlePointerUp={handlePointerUp}\n                    />\n                );\n            })}\n            {mode.startsWith('line') && active && (\n                <LineWrapper\n                    // @ts-expect-error\n                    id=\"create_in_progress___no_use\"\n                    x1={graph.current.getNodeAttribute(active, 'x')}\n                    y1={graph.current.getNodeAttribute(active, 'y')}\n                    x2={graph.current.getNodeAttribute(active, 'x') - movingPosition.x}\n                    y2={graph.current.getNodeAttribute(active, 'y') - movingPosition.y}\n                    newLine={true}\n                    type={mode.slice(5) as LinePathType}\n                    attrs={linePaths[mode.slice(5) as LinePathType].defaultAttrs}\n                    styleType={LineStyleType.SingleColor}\n                    styleAttrs={{ color: theme }}\n                />\n            )}\n        </>\n    );\n};\n\nexport default SvgCanvas;\n","import React from 'react';\nimport useEvent from 'react-use-event-hook';\nimport { nanoid } from 'nanoid';\nimport rmgRuntime from '@railmapgen/rmg-runtime';\nimport { Events, RuntimeMode } from '../constants/constants';\nimport { StationType } from '../constants/stations';\nimport { MiscNodeType } from '../constants/nodes';\nimport { useRootDispatch, useRootSelector } from '../redux';\nimport { redoAction, saveGraph, setSvgViewBoxMin, setSvgViewBoxZoom, undoAction } from '../redux/param/param-slice';\nimport {\n    clearSelected,\n    setActive,\n    setKeepLastPath,\n    setMode,\n    setNodeExists,\n    setRefreshEdges,\n    setRefreshNodes,\n} from '../redux/runtime/runtime-slice';\nimport SvgCanvas from './svg-canvas-graph';\nimport stations from './svgs/stations/stations';\nimport miscNodes from './svgs/nodes/misc-nodes';\nimport { getMousePosition, isMacClient, roundToNearestN } from '../util/helpers';\nimport { Size, useWindowSize } from '../util/hooks';\n\nconst SvgWrapper = () => {\n    const dispatch = useRootDispatch();\n    const graph = React.useRef(window.graph);\n    const refreshAndSave = () => {\n        dispatch(setRefreshNodes());\n        dispatch(setRefreshEdges());\n        dispatch(saveGraph(graph.current.export()));\n    };\n\n    const {\n        telemetry: { project: isAllowProjectTelemetry },\n    } = useRootSelector(state => state.app);\n    const { svgViewBoxZoom, svgViewBoxMin } = useRootSelector(state => state.param);\n    const {\n        mode,\n        lastTool,\n        active,\n        selected,\n        keepLastPath,\n        theme,\n        refresh: { nodes: refreshNodes },\n        nodeExists,\n    } = useRootSelector(state => state.runtime);\n\n    // Update nodeExists on each update and add mtr fonts if needed.\n    // If later other nodes want to hook some special logic like mtr fonts,\n    // loadMTRFonts(nodeExists: { [key in NodeType]: boolean }) is required and so do other hooks.\n    React.useEffect(() => {\n        const nodeExistsCopy = JSON.parse(JSON.stringify(nodeExists));\n        graph.current.forEachNode(node => {\n            const type = graph.current.getNodeAttribute(node, 'type');\n            nodeExistsCopy[type] = true;\n        });\n        dispatch(setNodeExists(nodeExistsCopy));\n\n        let link: HTMLLinkElement;\n        if (nodeExistsCopy[StationType.MTR]) {\n            link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.id = 'fonts_mtr';\n            link.href = process.env.PUBLIC_URL + `/styles/fonts_mtr.css`;\n            document.head.append(link);\n        }\n        return () => {\n            if (link) {\n                document.head.removeChild(link);\n            }\n        };\n    }, [refreshNodes]);\n\n    const [offset, setOffset] = React.useState({ x: 0, y: 0 });\n    const [svgViewBoxMinTmp, setSvgViewBoxMinTmp] = React.useState({ x: 0, y: 0 });\n    const handleBackgroundDown = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        const { x, y } = getMousePosition(e);\n        if (mode.startsWith('station')) {\n            dispatch(setMode('free'));\n            const rand = nanoid(10);\n            const type = mode.slice(8) as StationType;\n\n            // deep copy to prevent mutual reference\n            const attr = JSON.parse(JSON.stringify(stations[type].defaultAttrs));\n            // special tweaks for AttributesWithColor\n            if ('color' in attr) attr.color = theme;\n\n            graph.current.addNode(`stn_${rand}`, {\n                visible: true,\n                zIndex: 0,\n                x: roundToNearestN((x * svgViewBoxZoom) / 100 + svgViewBoxMin.x, 10),\n                y: roundToNearestN((y * svgViewBoxZoom) / 100 + svgViewBoxMin.y, 10),\n                type,\n                [type]: attr,\n            });\n            // console.log('down', active, offset);\n            refreshAndSave();\n            if (isAllowProjectTelemetry) rmgRuntime.event(Events.ADD_STATION, { type });\n        } else if (mode.startsWith('misc-node')) {\n            dispatch(setMode('free'));\n            const rand = nanoid(10);\n            const type = mode.slice(10) as MiscNodeType;\n            graph.current.addNode(`misc_node_${rand}`, {\n                visible: true,\n                zIndex: 0,\n                x: roundToNearestN((x * svgViewBoxZoom) / 100 + svgViewBoxMin.x, 10),\n                y: roundToNearestN((y * svgViewBoxZoom) / 100 + svgViewBoxMin.y, 10),\n                type,\n                // deep copy to prevent mutual reference\n                [type]: JSON.parse(JSON.stringify(miscNodes[type].defaultAttrs)),\n            });\n            refreshAndSave();\n            if (isAllowProjectTelemetry) rmgRuntime.event(Events.ADD_STATION, { type });\n        } else if (mode === 'free' || mode.startsWith('line')) {\n            // deselect line tool if user clicks on the background\n            if (mode.startsWith('line')) {\n                dispatch(setMode('free'));\n                // also turn keepLastPath off to exit keeping drawing lines\n                if (keepLastPath) dispatch(setKeepLastPath(false));\n            }\n\n            // set initial position of the pointer, this is used in handleBackgroundMove\n            setOffset({ x, y });\n            setSvgViewBoxMinTmp(svgViewBoxMin);\n            if (!e.shiftKey) {\n                // when user holding the shift key and mis-click the background\n                // preserve the current selection\n                dispatch(setActive('background'));\n                dispatch(clearSelected());\n            }\n            // console.log(x, y, svgViewBoxMin);\n        }\n    });\n    const handleBackgroundMove = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        if (active === 'background') {\n            const { x, y } = getMousePosition(e);\n            dispatch(\n                setSvgViewBoxMin({\n                    x: svgViewBoxMinTmp.x + ((offset.x - x) * svgViewBoxZoom) / 100,\n                    y: svgViewBoxMinTmp.y + ((offset.y - y) * svgViewBoxZoom) / 100,\n                })\n            );\n            // console.log('move', active, { x: offset.x - x, y: offset.y - y }, svgViewBoxMin);\n        }\n    });\n    const handleBackgroundUp = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        // when user holding the shift key and mis-click the background\n        // preserve the current selection\n        if (active === 'background' && !e.shiftKey) {\n            dispatch(setActive(undefined)); // svg mouse event only\n            // console.log('up', active);\n        }\n    });\n\n    const handleBackgroundWheel = useEvent((e: React.WheelEvent<SVGSVGElement>) => {\n        let newSvgViewBoxZoom = svgViewBoxZoom;\n        if (e.deltaY > 0 && svgViewBoxZoom + 10 < 400) newSvgViewBoxZoom = svgViewBoxZoom + 10;\n        else if (e.deltaY < 0 && svgViewBoxZoom - 10 > 0) newSvgViewBoxZoom = svgViewBoxZoom - 10;\n        dispatch(setSvgViewBoxZoom(newSvgViewBoxZoom));\n\n        // the position the pointer points will still be in the same place after zooming\n        const { x, y } = getMousePosition(e);\n        const bbox = e.currentTarget.getBoundingClientRect();\n        // calculate the proportion of the pointer in the canvas\n        const [x_factor, y_factor] = [x / bbox.width, y / bbox.height];\n        // the final svgViewBoxMin will be the position the pointer points minus\n        // the left/top part of the new canvas (new width/height times the proportion)\n        dispatch(\n            setSvgViewBoxMin({\n                x: svgViewBoxMin.x + (x * svgViewBoxZoom) / 100 - ((width * newSvgViewBoxZoom) / 100) * x_factor,\n                y: svgViewBoxMin.y + (y * svgViewBoxZoom) / 100 - ((height * newSvgViewBoxZoom) / 100) * y_factor,\n            })\n        );\n    });\n\n    const handleKeyDown = useEvent((e: React.KeyboardEvent<SVGSVGElement>) => {\n        e.preventDefault();\n        // tabIndex need to be on the element to make onKeyDown worked\n        // https://www.delftstack.com/howto/react/onkeydown-react/\n        if (isMacClient ? e.key === 'Backspace' : e.key === 'Delete') {\n            // remove all the selected nodes and edges\n            if (selected.length > 0) {\n                selected\n                    .filter(s => graph.current.hasNode(s) || graph.current.hasEdge(s))\n                    .forEach(s => {\n                        dispatch(clearSelected());\n                        graph.current.hasNode(s) ? graph.current.dropNode(s) : graph.current.dropEdge(s);\n                        refreshAndSave();\n                    });\n            }\n        } else if (e.key.startsWith('Arrow')) {\n            const d = 100;\n            const x_factor = e.key.endsWith('Left') ? -1 : e.key.endsWith('Right') ? 1 : 0;\n            const y_factor = e.key.endsWith('Up') ? -1 : e.key.endsWith('Down') ? 1 : 0;\n            dispatch(\n                setSvgViewBoxMin({\n                    x: svgViewBoxMin.x + ((d * svgViewBoxZoom) / 100) * x_factor,\n                    y: svgViewBoxMin.y + ((d * svgViewBoxZoom) / 100) * y_factor,\n                })\n            );\n        } else if (e.key === 'i' || e.key === 'j' || e.key === 'k' || e.key === 'l') {\n            const d = 10;\n            const x_factor = (e.key === 'j' ? -1 : e.key === 'l' ? 1 : 0) * d;\n            const y_factor = (e.key === 'i' ? -1 : e.key === 'k' ? 1 : 0) * d;\n            if (selected.length > 0) {\n                selected\n                    .filter(s => graph.current.hasNode(s))\n                    .forEach(s => {\n                        graph.current.updateNodeAttribute(s, 'x', x => (x ?? 0) + x_factor);\n                        graph.current.updateNodeAttribute(s, 'y', y => (y ?? 0) + y_factor);\n                        refreshAndSave();\n                    });\n            }\n        } else if (e.key === 'f' && lastTool) {\n            dispatch(setMode(lastTool as RuntimeMode));\n        } else if (e.key === 'z' && (isMacClient ? e.metaKey && !e.shiftKey : e.ctrlKey)) {\n            dispatch(undoAction());\n        } else if (\n            (isMacClient && e.key === 'z' && e.metaKey && e.shiftKey) ||\n            (!isMacClient && e.key === 'y' && e.ctrlKey)\n        ) {\n            dispatch(redoAction());\n        }\n    });\n\n    const size: Size = useWindowSize();\n    const height = (size.height ?? 1280) - 40;\n    const width = (size.width ?? 720) - 50;\n\n    return (\n        <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            id=\"canvas\"\n            style={{ position: 'fixed', top: 40, left: 50 }}\n            height={height}\n            width={width}\n            viewBox={`${svgViewBoxMin.x} ${svgViewBoxMin.y} ${(width * svgViewBoxZoom) / 100} ${\n                (height * svgViewBoxZoom) / 100\n            }`}\n            onPointerDown={handleBackgroundDown}\n            onPointerMove={handleBackgroundMove}\n            onPointerUp={handleBackgroundUp}\n            onWheel={handleBackgroundWheel}\n            tabIndex={0}\n            onKeyDown={handleKeyDown}\n        >\n            <SvgCanvas />\n        </svg>\n    );\n};\n\nexport default SvgWrapper;\n","import { useState, useEffect } from 'react';\n\n// Define general type for useWindowSize hook, which includes width and height\nexport interface Size {\n    width: number | undefined;\n    height: number | undefined;\n}\n\n// Hook\nexport const useWindowSize = (): Size => {\n    // Initialize state with undefined width/height so server and client renders match\n    // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n    const [windowSize, setWindowSize] = useState<Size>({\n        width: undefined,\n        height: undefined,\n    });\n\n    useEffect(() => {\n        // Handler to call on window resize\n        function handleResize() {\n            // Set window width/height to state\n            setWindowSize({\n                width: window.innerWidth,\n                height: window.innerHeight,\n            });\n        }\n\n        // Add event listener\n        window.addEventListener('resize', handleResize);\n\n        // Call handler right away so state gets updated with initial window size\n        handleResize();\n\n        // Remove event listener on cleanup\n        return () => window.removeEventListener('resize', handleResize);\n    }, []); // Empty array ensures that effect is only run on mount\n\n    return windowSize;\n};\n","import { MultiDirectedGraph } from 'graphology';\nimport { NodeAttributes, EdgeAttributes, GraphAttributes } from '../constants/constants';\n\nexport const getMousePosition = (e: React.MouseEvent) => {\n    const bbox = e.currentTarget.getBoundingClientRect();\n    const x = e.clientX - bbox.left;\n    const y = e.clientY - bbox.top;\n    // console.log(e.clientX, bbox.left, e.clientY, bbox.top, x, y);\n    return { x, y };\n};\n\nexport const roundToNearestN = (x: number, n: number) => Math.round(x / n) * n;\n\nexport const calculateCanvasSize = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    let [xMin, yMin, xMax, yMax] = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE];\n\n    graph.forEachNode((node, attr) => {\n        xMin = Math.min(attr.x, xMin);\n        yMin = Math.min(attr.y, yMin);\n        xMax = Math.max(attr.x, xMax);\n        yMax = Math.max(attr.y, yMax);\n    });\n\n    xMin -= 150;\n    yMin -= 150;\n    xMax += 150;\n    yMax += 150;\n\n    return { xMin, yMin, xMax, yMax };\n};\n\nexport const isMacClient = navigator.platform.startsWith('Mac');\n","import {\n  useLayoutEffect,\n  useRef,\n  useInsertionEffect, // Only available in React 18+\n} from \"react\";\n\ntype AnyFunction = (...args: any[]) => any;\n\n/**\n * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)\n * Make use of useInsertionEffect if available.\n */\nconst useBrowserEffect = typeof window !== \"undefined\" ? useInsertionEffect ?? useLayoutEffect : () => {};\n\n/**\n * Similar to useCallback, with a few subtle differences:\n * - The returned function is a stable reference, and will always be the same between renders\n * - No dependency lists required\n * - Properties or state accessed within the callback will always be \"current\"\n */\nexport function useEvent<TCallback extends AnyFunction>(callback: TCallback): TCallback {\n  // Keep track of the latest callback:\n  const latestRef = useRef<TCallback>(useEvent_shouldNotBeInvokedBeforeMount as any);\n  useBrowserEffect(() => {\n    latestRef.current = callback;\n  }, [callback]);\n\n  // Create a stable callback that always calls the latest callback:\n  // using useRef instead of useCallback avoids creating and empty array on every render\n  const stableRef = useRef<TCallback>(null as any);\n  if (!stableRef.current) {\n    stableRef.current = function (this: any) {\n      return latestRef.current.apply(this, arguments as any);\n    } as TCallback;\n  }\n\n  return stableRef.current;\n}\n\n/**\n * Render methods should be pure, especially when concurrency is used,\n * so we will throw this error if the callback is called while rendering.\n */\nfunction useEvent_shouldNotBeInvokedBeforeMount() {\n  throw new Error(\n    \"INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.\"\n  );\n}\n\nexport default useEvent;\n","import {\n  Stack\n} from \"./chunk-O5CRURSQ.mjs\";\n\n// src/stack/h-stack.tsx\nimport { forwardRef } from \"@chakra-ui/system\";\nimport { jsx } from \"react/jsx-runtime\";\nvar HStack = forwardRef((props, ref) => /* @__PURE__ */ jsx(Stack, { align: \"center\", ...props, direction: \"row\", ref }));\nHStack.displayName = \"HStack\";\n\nexport {\n  HStack\n};\n"],"names":["props","id","type","attrs","styleType","styleAttrs","lineStyles","defaultAttrs","newLine","handleClick","x1","y1","x2","y2","React","path","setPath","linePaths","generatePath","JSON","stringify","StyleComponent","component","graph","lineGroupToReconcile","linesNeedToReconcile","filterDirectedEdges","edge","attr","source","target","sourceAttr","targetAttr","undirected","startsWith","reconcileId","lineNeedReconcile","getEdgeAttribute","push","getAllLinesNeedToReconcile","allReconciledLines","danglingLines","Object","values","forEach","length","at","every","line","style","count","sources","Set","targets","extremities","fromEntries","map","add","source_","Array","from","filter","s","target_","t","reconciledLines","currentNode","i","currentTarget","getStations","filterNodes","node","getNodeAttributes","visible","sort","a","b","zIndex","x","y","getLines","styleAttr","getMiscNodes","dispatch","useRootDispatch","window","isAllowProjectTelemetry","useRootSelector","state","app","telemetry","project","svgViewBoxZoom","param","runtime","selected","refresh","refreshNodes","nodes","refreshEdges","edges","mode","active","keepLastPath","theme","offset","setOffset","movingPosition","setMovingPosition","handlePointerDown","useEvent","e","stopPropagation","el","getMousePosition","setPointerCapture","pointerId","setActive","shiftKey","clearSelected","addSelected","handlePointerMove","current","updateNodeAttributes","roundToNearestN","altKey","setRefreshNodes","setRefreshEdges","handlePointerUp","setMode","prefix","document","elementsFromPoint","clientX","clientY","attributes","getNamedItem","value","slice","newLineId","nanoid","addDirectedEdgeWithKey","parse","LineStyleType","color","rmgRuntime","Events","saveGraph","export","undefined","handleEdgeClick","stations","setStations","setNodes","lines","setLines","setReconciledLines","setDanglingLines","reconcileLines","LinePathType","reconciledLine","hasEdge","paths","replace","generateReconciledPath","n","MiscNodeComponent","miscNodes","station","StationComponent","allStations","getNodeAttribute","refreshAndSave","svgViewBoxMin","lastTool","nodeExists","link","nodeExistsCopy","forEachNode","setNodeExists","StationType","createElement","rel","href","process","head","append","removeChild","svgViewBoxMinTmp","setSvgViewBoxMinTmp","handleBackgroundDown","rand","addNode","setKeepLastPath","handleBackgroundMove","setSvgViewBoxMin","handleBackgroundUp","handleBackgroundWheel","newSvgViewBoxZoom","deltaY","setSvgViewBoxZoom","bbox","getBoundingClientRect","x_factor","width","y_factor","height","handleKeyDown","preventDefault","isMacClient","key","hasNode","dropNode","dropEdge","endsWith","updateNodeAttribute","metaKey","ctrlKey","undoAction","redoAction","size","useState","windowSize","setWindowSize","useEffect","handleResize","innerWidth","innerHeight","addEventListener","removeEventListener","useWindowSize","xmlns","position","top","left","viewBox","onPointerDown","onPointerMove","onPointerUp","onWheel","tabIndex","onKeyDown","Math","round","calculateCanvasSize","Number","MAX_VALUE","MIN_VALUE","xMin","yMin","xMax","yMax","min","max","navigator","platform","useBrowserEffect","react_1","useInsertionEffect","callback","latestRef","useRef","useEvent_shouldNotBeInvokedBeforeMount","stableRef","apply","this","arguments","Error","exports","HStack","forwardRef","ref","jsx","Stack","align","direction","displayName"],"sourceRoot":""}