{"version":3,"file":"static/js/SvgWrapper.71d1221a.chunk.js","mappings":"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","sources":["util/reconcile.ts","util/processElements.ts","components/svg-canvas-graph.tsx","components/svg-wrapper.tsx","util/hooks.ts","util/helpers.ts","../node_modules/react-use-event-hook/src/useEvent.ts","../node_modules/nanoid/index.browser.js"],"sourcesContent":["import { MultiDirectedGraph } from 'graphology';\nimport lines from '../components/line/lines';\nimport miscEdges from '../components/edges/misc-edges';\nimport { LineId, NodeAttributes, EdgeAttributes, GraphAttributes } from '../constants/constants';\nimport { roundPathCorners } from './pathRounding';\n\nconst edges = { ...lines, ...miscEdges };\n\n/**\n * Only lines have a reconcileId will be considered.\n */\nconst getAllLinesNeedToReconcile = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    const linesNeedToReconcile = graph.filterDirectedEdges(\n        (edge, attr, source, target, sourceAttr, targetAttr, undirected) =>\n            edge.startsWith('line') && attr.reconcileId !== ''\n    ) as LineId[];\n\n    const lineGroupToReconcile: { [reconcileId: string]: LineId[] } = {};\n    for (const lineNeedReconcile of linesNeedToReconcile) {\n        const reconcileId = graph.getEdgeAttribute(lineNeedReconcile, 'reconcileId');\n        if (reconcileId in lineGroupToReconcile) lineGroupToReconcile[reconcileId].push(lineNeedReconcile);\n        else lineGroupToReconcile[reconcileId] = [lineNeedReconcile];\n    }\n\n    return lineGroupToReconcile;\n};\n\n/**\n * Reconcile lines to a single path.\n *\n * It will try to find a path from one source to one target if\n * the lines are set correctly. All the lines need to implement\n * the generatePath function.\n */\nconst reconcileLines = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    const lineGroupToReconcile = getAllLinesNeedToReconcile(graph);\n    // console.log(lineGroupToReconcile);\n\n    const allReconciledLines: LineId[][] = [];\n    const danglingLines: LineId[] = [];\n    Object.values(lineGroupToReconcile).forEach(linesNeedToReconcile => {\n        // it is not possible to reconcile a single line\n        if (linesNeedToReconcile.length === 1) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // every type of line in linesNeedToReconcile should implement generatePath function\n        if (!linesNeedToReconcile.every(line => edges[graph.getEdgeAttribute(line, 'type')].generatePath)) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // find the source and target for the whole line\n        const count: { [node: string]: number } = {}; // count on evert nodes' occurrence\n        const sources: Set<string> = new Set();\n        const targets: Set<string> = new Set();\n        const extremities = Object.fromEntries(\n            linesNeedToReconcile.map(line => {\n                const [source, target] = graph.extremities(line);\n                count[source] = (count[source] ?? 0) + 1;\n                count[target] = (count[target] ?? 0) + 1;\n                sources.add(source);\n                targets.add(target);\n                return [source, [line, target] as [LineId, string]];\n            })\n        );\n\n        // source need to be the node appear only once in all sources and targets\n        // and there must be only one.\n        const source_ = Array.from(sources).filter(s => count[s] === 1);\n        const target_ = Array.from(targets).filter(t => count[t] === 1);\n        // console.log(source_, target_, count);\n        if (source_.length !== 1 || target_.length !== 1) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n        const source = source_[0];\n        const target = target_[0];\n        if (source === target) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n\n        // start from source, find each consecutive line\n        const reconciledLines: LineId[] = [extremities[source][0]];\n        let currentNode = extremities[source][1];\n        for (let i = 1; i < linesNeedToReconcile.length; i = i + 1) {\n            const currentTarget = extremities[currentNode]?.at(1);\n            // console.log(currentNode, extremities[currentNode]?.at(0), currentTarget);\n            if (!currentTarget) {\n                danglingLines.push(...linesNeedToReconcile);\n                return;\n            }\n\n            reconciledLines.push(extremities[currentNode][0]);\n            currentNode = currentTarget;\n        }\n        // console.log(currentNode, reconciledLines);\n        if (currentNode !== target || reconciledLines.length !== linesNeedToReconcile.length) {\n            danglingLines.push(...linesNeedToReconcile);\n            return;\n        }\n        allReconciledLines.push(reconciledLines);\n    });\n\n    return { allReconciledLines, danglingLines };\n};\n\nexport default reconcileLines;\n\n/**\n * Call each lines' generatePath and merge all the path to a single one.\n */\nexport const generateReconciledPath = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>,\n    reconciledLine: LineId[]\n) => {\n    if (!reconciledLine.every(line => graph.hasEdge(line))) return '';\n\n    // call each line to generate its own path\n    const paths = reconciledLine.map(line => {\n        const [source, target] = graph.extremities(line);\n        const sourceAttr = graph.getNodeAttributes(source);\n        const targetAttr = graph.getNodeAttributes(target);\n        const type = graph.getEdgeAttribute(line, 'type');\n        const attr = graph.getEdgeAttribute(line, type) ?? edges[type].defaultAttrs;\n        // @ts-ignore-error\n        return lines[type].generatePath!(sourceAttr.x, targetAttr.x, sourceAttr.y, targetAttr.y, attr);\n    });\n    // console.log(reconciledLine, paths);\n\n    // merge paths to one\n    let path = `${paths[0].d} `;\n    for (let i = 1; i < reconciledLine.length; i = i + 1) {\n        // path += `L ${paths[i].d.slice(1)} `;\n        path += paths[i].d.replace(/M\\s*-?\\d+(\\.\\d+)?(\\s*|,)-?\\d+(\\.*\\d+)?\\s*/i, '');\n    }\n    // console.log(path);\n\n    return roundPathCorners(path, 7.5, false) as string;\n};\n","import { MultiDirectedGraph } from 'graphology';\nimport {\n    StnId,\n    LineId,\n    MiscNodeId,\n    NodeAttributes,\n    EdgeAttributes,\n    GraphAttributes,\n    MiscEdgeId,\n} from '../constants/constants';\nimport { StationType } from '../constants/stations';\nimport { MiscNodeType } from '../constants/nodes';\nimport { LineType } from '../constants/lines';\nimport { MiscEdgeType } from '../constants/edges';\n\n/**\n * This file contains helper methods to extract stations/miscNodes/lines/miscEdges\n * from MultiDirectedGraph and return elements that svg-canvas can directly use in\n * various aforementioned components.\n */\n\ntype StationElem = NodeAttributes & { node: StnId; type: StationType };\nexport const getStations = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>\n): StationElem[] =>\n    graph\n        .filterNodes((node, attr) => node.startsWith('stn'))\n        .map(node => [node, graph.getNodeAttributes(node)] as [StnId, NodeAttributes])\n        .filter(([node, attr]) => attr.visible)\n        .map(([node, attr]) => ({\n            node: node as StnId,\n            visible: attr.visible,\n            zIndex: attr.zIndex,\n            x: attr.x,\n            y: attr.y,\n            type: attr.type as StationType,\n            [attr.type]: attr[attr.type],\n        }));\n\ntype LineElem = {\n    edge: LineId;\n    x1: number;\n    x2: number;\n    y1: number;\n    y2: number;\n    attr: EdgeAttributes;\n    type: LineType;\n};\nexport const getLines = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>): LineElem[] =>\n    graph\n        .filterDirectedEdges(\n            (edge, attr, source, target, sourceAttr, targetAttr, undirected) =>\n                edge.startsWith('line') && attr.visible && attr.reconcileId === ''\n        )\n        .map(edge => {\n            const [source, target] = graph.extremities(edge);\n            const attr = graph.getEdgeAttributes(edge);\n            const sourceAttr = graph.getNodeAttributes(source);\n            const targetAttr = graph.getNodeAttributes(target);\n            return {\n                edge: edge as LineId,\n                x1: sourceAttr.x,\n                y1: sourceAttr.y,\n                x2: targetAttr.x,\n                y2: targetAttr.y,\n                attr: attr,\n                type: attr.type as LineType,\n            };\n        });\n\ntype MiscNodeElem = NodeAttributes & { node: MiscNodeId; type: MiscNodeType };\nexport const getMiscNodes = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>\n): MiscNodeElem[] =>\n    graph\n        .filterNodes((node, attr) => node.startsWith('misc_node'))\n        .map(node => [node, graph.getNodeAttributes(node)] as [MiscNodeId, NodeAttributes])\n        .filter(([node, attr]) => attr.visible)\n        .map(([node, attr]) => ({\n            node,\n            visible: attr.visible,\n            zIndex: attr.zIndex,\n            x: attr.x,\n            y: attr.y,\n            type: attr.type as MiscNodeType,\n            [attr.type]: attr[attr.type],\n        }));\n\ntype MiscEdgeElem = {\n    edge: MiscEdgeId;\n    x1: number;\n    x2: number;\n    y1: number;\n    y2: number;\n    attr: EdgeAttributes;\n    type: MiscEdgeType;\n};\nexport const getMiscEdges = (\n    graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>\n): MiscEdgeElem[] =>\n    graph\n        .filterDirectedEdges(\n            (edge, attr, source, target, sourceAttr, targetAttr, undirected) =>\n                edge.startsWith('misc_edge') && attr.visible && attr.reconcileId === ''\n        )\n        .map(edge => {\n            const [source, target] = graph.extremities(edge);\n            const attr = graph.getEdgeAttributes(edge);\n            const sourceAttr = graph.getNodeAttributes(source);\n            const targetAttr = graph.getNodeAttributes(target);\n            return {\n                edge: edge as MiscEdgeId,\n                x1: sourceAttr.x,\n                y1: sourceAttr.y,\n                x2: targetAttr.x,\n                y2: targetAttr.y,\n                attr: attr,\n                type: attr.type as MiscEdgeType,\n            };\n        });\n","import React from 'react';\nimport useEvent from 'react-use-event-hook';\nimport { nanoid } from 'nanoid';\nimport { StnId, LineId, MiscNodeId, MiscEdgeId } from '../constants/constants';\nimport { LineType } from '../constants/lines';\nimport { useRootDispatch, useRootSelector } from '../redux';\nimport { saveGraph } from '../redux/app/app-slice';\nimport { setActive, addSelected, setRefresh, setMode, clearSelected } from '../redux/runtime/runtime-slice';\nimport { MiscEdgeType } from '../constants/edges';\nimport allStations from './station/stations';\nimport allLines from './line/lines';\nimport miscNodes from './nodes/misc-nodes';\nimport miscEdges from './edges/misc-edges';\nimport { getMousePosition, roundToNearestN } from '../util/helpers';\nimport reconcileLines, { generateReconciledPath } from '../util/reconcile';\nimport { getStations, getMiscNodes, getLines, getMiscEdges } from '../util/processElements';\n\nconst EDGES = { ...allLines, ...miscEdges };\n\nconst SvgCanvas = () => {\n    const dispatch = useRootDispatch();\n\n    const {\n        selected,\n        refresh: { all: refreshAll, reconcileLine },\n        mode,\n        active,\n        theme,\n    } = useRootSelector(state => state.runtime);\n    const { svgViewBoxZoom } = useRootSelector(state => state.app);\n    const refreshAndSave = () => {\n        dispatch(setRefresh());\n        dispatch(saveGraph(graph.current.export()));\n    };\n\n    const graph = React.useRef(window.graph);\n\n    const [offset, setOffset] = React.useState({ x: 0, y: 0 });\n    const [newLinePosition, setNewLinePosition] = React.useState({ x: 0, y: 0 });\n\n    const handlePointerDown = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        const el = e.currentTarget;\n        const { x, y } = getMousePosition(e);\n        el.setPointerCapture(e.pointerId);\n\n        setOffset({ x, y });\n\n        dispatch(setActive(node)); // svg mouse event only\n        // details panel only, remove all if this is not a multiple selection\n        if (!e.shiftKey && selected.length <= 1) dispatch(clearSelected());\n        dispatch(addSelected(node)); // details panel only\n        // console.log('down ', graph.current.getNodeAttributes(node));\n    });\n    const handlePointerMove = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        const { x, y } = getMousePosition(e);\n\n        if (mode === 'free' && active === node) {\n            selected.forEach(s => {\n                graph.current.updateNodeAttributes(s, attr => ({\n                    ...attr,\n                    x: roundToNearestN(attr.x - ((offset.x - x) * svgViewBoxZoom) / 100, e.altKey ? 1 : 5),\n                    y: roundToNearestN(attr.y - ((offset.y - y) * svgViewBoxZoom) / 100, e.altKey ? 1 : 5),\n                }));\n            });\n            refreshAndSave();\n            // console.log('move ', graph.current.getNodeAttributes(node));\n        } else if (mode.startsWith('line') || mode.startsWith('misc-edge')) {\n            setNewLinePosition({\n                x: ((offset.x - x) * svgViewBoxZoom) / 100,\n                y: ((offset.y - y) * svgViewBoxZoom) / 100,\n            });\n        }\n    });\n    const handlePointerUp = useEvent((node: StnId | MiscNodeId, e: React.PointerEvent<SVGElement>) => {\n        e.stopPropagation();\n\n        if (mode.startsWith('line') || mode.startsWith('misc-edge')) {\n            dispatch(setMode('free'));\n\n            const prefixs = ['stn_core_', 'virtual_circle_'];\n            prefixs.forEach(prefix => {\n                const elems = document.elementsFromPoint(e.clientX, e.clientY);\n                const id = elems[0].attributes?.getNamedItem('id')?.value;\n                if (id?.startsWith(prefix)) {\n                    const type = mode.startsWith('line')\n                        ? (mode.slice(5) as LineType)\n                        : (mode.slice(10) as MiscEdgeType);\n                    const newLineId = `${mode.startsWith('line') ? 'line' : 'misc_edge'}_${nanoid(10)}`;\n                    graph.current.addDirectedEdgeWithKey(newLineId, active, id.slice(prefix.length), {\n                        visible: true,\n                        zIndex: 0,\n                        color: theme,\n                        type,\n                        // deep copy to prevent mutual reference\n                        [type]: JSON.parse(JSON.stringify(EDGES[type].defaultAttrs)),\n                        reconcileId: '',\n                    });\n                }\n            });\n        } else if (mode === 'free') {\n            // check the offset and if it's not 0, it must be a click not move\n            // then dispatch the current station/line to display the details\n            const { x, y } = getMousePosition(e);\n            if (offset.x - x === 0 && offset.y - y === 0) {\n                dispatch(setActive(node)); // svg mouse event only\n            }\n        }\n        dispatch(setActive(undefined)); // svg mouse event only\n        refreshAndSave();\n        // console.log('up ', graph.current.getNodeAttributes(node));\n    });\n    const handleEdgeClick = useEvent((edge: LineId | MiscEdgeId, e: React.MouseEvent<SVGPathElement, MouseEvent>) => {\n        dispatch(clearSelected());\n        dispatch(addSelected(edge));\n    });\n\n    // These are states that the svg draws from.\n    // They are updated by refresh trigger in runtime slice.\n    const [stations, setStations] = React.useState(getStations(graph.current));\n    const [lines, setLines] = React.useState(getLines(graph.current));\n    const [nodes, setNodes] = React.useState(getMiscNodes(graph.current));\n    const [edges, setEdges] = React.useState(getMiscEdges(graph.current));\n    const [allReconciledLines, setAllReconciledLines] = React.useState([] as LineId[][]);\n    const [danglingLines, setDanglingLines] = React.useState([] as LineId[]);\n    React.useEffect(() => {\n        setStations(getStations(graph.current));\n        setLines(getLines(graph.current));\n        setNodes(getMiscNodes(graph.current));\n        setEdges(getMiscEdges(graph.current));\n    }, [refreshAll]);\n    React.useEffect(() => {\n        const { allReconciledLines, danglingLines } = reconcileLines(graph.current);\n        setAllReconciledLines(allReconciledLines);\n        setDanglingLines(danglingLines);\n    }, []);\n    React.useEffect(() => {\n        const { allReconciledLines, danglingLines } = reconcileLines(graph.current);\n        setAllReconciledLines(allReconciledLines);\n        setDanglingLines(danglingLines);\n    }, [reconcileLine]);\n\n    const DrawLineComponent =\n        mode.startsWith('line') || mode.startsWith('misc-edge')\n            ? EDGES[mode.startsWith('line') ? (mode.slice(5) as LineType) : (mode.slice(10) as MiscEdgeType)].component\n            : (props: any) => <></>;\n\n    return (\n        <>\n            {danglingLines.map(edge => {\n                const LineComponent = allLines[LineType.Simple].component;\n                const [source, target] = graph.current.extremities(edge);\n                const sourceAttr = graph.current.getNodeAttributes(source);\n                const targetAttr = graph.current.getNodeAttributes(target);\n                return (\n                    <LineComponent\n                        id={edge as LineId}\n                        key={edge}\n                        x1={sourceAttr.x}\n                        y1={sourceAttr.y}\n                        x2={targetAttr.x}\n                        y2={targetAttr.y}\n                        newLine={false}\n                        attrs={graph.current.getEdgeAttributes(edge)}\n                        handleClick={handleEdgeClick}\n                    />\n                );\n            })}\n            {allReconciledLines.map(reconciledLine => {\n                const path = generateReconciledPath(graph.current, reconciledLine);\n                if (path === '') return <></>;\n                const color = graph.current.getEdgeAttribute(reconciledLine[0], 'color');\n\n                // TODO: reconciled line could be clicked\n\n                return (\n                    <path\n                        key={reconciledLine.join(',')}\n                        d={path}\n                        fill=\"none\"\n                        stroke={color[2]}\n                        strokeWidth={5}\n                        strokeLinejoin=\"round\"\n                    />\n                );\n            })}\n            {nodes.map(n => {\n                const { node, x, y, type } = n;\n                const MiscNodeComponent = miscNodes[type].component;\n                return (\n                    <MiscNodeComponent\n                        id={node}\n                        key={node}\n                        x={x}\n                        y={y}\n                        // @ts-expect-error\n                        attrs={n[type]}\n                        handlePointerDown={handlePointerDown}\n                        handlePointerMove={handlePointerMove}\n                        handlePointerUp={handlePointerUp}\n                    />\n                );\n            })}\n            {[...lines, ...edges].map(({ edge, x1, y1, x2, y2, attr, type }) => {\n                const EdgeComponent = EDGES[type].component;\n                return (\n                    <EdgeComponent\n                        // @ts-expect-error\n                        id={edge as LineId | MiscEdgeId}\n                        key={edge}\n                        x1={x1}\n                        y1={y1}\n                        x2={x2}\n                        y2={y2}\n                        newLine={false}\n                        attrs={attr}\n                        handleClick={handleEdgeClick}\n                    />\n                );\n            })}\n            {stations.map(station => {\n                const { node, x, y, type } = station;\n                const StationComponent = allStations[type].component;\n                return (\n                    <StationComponent\n                        id={node}\n                        key={node}\n                        x={x}\n                        y={y}\n                        attrs={{ [type]: station[type] }}\n                        handlePointerDown={handlePointerDown}\n                        handlePointerMove={handlePointerMove}\n                        handlePointerUp={handlePointerUp}\n                    />\n                );\n            })}\n            {(mode.startsWith('line') || mode.startsWith('misc-edge')) && active && (\n                <DrawLineComponent\n                    // @ts-expect-error\n                    id=\"create_in_progress___no_use\"\n                    x1={graph.current.getNodeAttribute(active, 'x')}\n                    y1={graph.current.getNodeAttribute(active, 'y')}\n                    x2={graph.current.getNodeAttribute(active, 'x') - newLinePosition.x}\n                    y2={graph.current.getNodeAttribute(active, 'y') - newLinePosition.y}\n                    newLine={true}\n                    attrs={{\n                        visible: true,\n                        zIndex: 0,\n                        color: theme,\n                        type: LineType.Diagonal,\n                        reconcileId: '',\n                    }}\n                />\n            )}\n        </>\n    );\n};\n\nexport default SvgCanvas;\n","import React from 'react';\nimport useEvent from 'react-use-event-hook';\nimport { nanoid } from 'nanoid';\nimport { useRootDispatch, useRootSelector } from '../redux';\nimport { Size, useWindowSize } from '../util/hooks';\nimport { getMousePosition, roundToNearestN } from '../util/helpers';\nimport { clearSelected, setActive, setMode, setRefresh } from '../redux/runtime/runtime-slice';\nimport { setSvgViewBoxZoom, setSvgViewBoxMin } from '../redux/app/app-slice';\nimport SvgCanvas from './svg-canvas-graph';\nimport { StationType } from '../constants/stations';\nimport { MiscNodeType } from '../constants/nodes';\nimport stations from './station/stations';\nimport miscNodes from './nodes/misc-nodes';\nimport { saveGraph } from '../redux/app/app-slice';\n\nconst SvgWrapper = () => {\n    const dispatch = useRootDispatch();\n    const refreshAndSave = () => {\n        dispatch(setRefresh());\n        dispatch(saveGraph(graph.current.export()));\n    };\n\n    const { mode, active, selected, theme } = useRootSelector(state => state.runtime);\n    const { svgViewBoxZoom, svgViewBoxMin } = useRootSelector(state => state.app);\n    const graph = React.useRef(window.graph);\n\n    const [offset, setOffset] = React.useState({ x: 0, y: 0 });\n    const [svgViewBoxMinTmp, setSvgViewBoxMinTmp] = React.useState({ x: 0, y: 0 });\n    const handleBackgroundDown = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        const { x, y } = getMousePosition(e);\n        if (mode.startsWith('station')) {\n            dispatch(setMode('free'));\n            const rand = nanoid(10);\n            const type = mode.slice(8) as StationType;\n\n            // deep copy to prevent mutual reference\n            const attr = JSON.parse(JSON.stringify(stations[type].defaultAttrs));\n            // special tweaks for AttributesWithColor\n            if ('color' in attr) attr.color = theme;\n\n            graph.current.addNode(`stn_${rand}`, {\n                visible: true,\n                zIndex: 0,\n                x: roundToNearestN((x * svgViewBoxZoom) / 100 + svgViewBoxMin.x, 10),\n                y: roundToNearestN((y * svgViewBoxZoom) / 100 + svgViewBoxMin.y, 10),\n                type,\n                [type]: attr,\n            });\n            // console.log('down', active, offset);\n            refreshAndSave();\n        } else if (mode.startsWith('misc-node')) {\n            dispatch(setMode('free'));\n            const rand = nanoid(10);\n            const type = mode.slice(10) as MiscNodeType;\n            graph.current.addNode(`misc_node_${rand}`, {\n                visible: true,\n                zIndex: 0,\n                x: roundToNearestN((x * svgViewBoxZoom) / 100 + svgViewBoxMin.x, 10),\n                y: roundToNearestN((y * svgViewBoxZoom) / 100 + svgViewBoxMin.y, 10),\n                type,\n                // deep copy to prevent mutual reference\n                [type]: JSON.parse(JSON.stringify(miscNodes[type].defaultAttrs)),\n            });\n            refreshAndSave();\n        } else if (mode === 'free' || mode.startsWith('line') || mode.startsWith('misc-edge')) {\n            // deselect line tool if user clicks on the background\n            if (mode.startsWith('line') || mode.startsWith('misc-edge')) dispatch(setMode('free'));\n\n            setOffset({ x, y });\n            setSvgViewBoxMinTmp(svgViewBoxMin);\n            if (!e.shiftKey) {\n                // when user holding the shift key and mis-click the background\n                // preserve the current selection\n                dispatch(setActive('background'));\n                dispatch(clearSelected());\n            }\n            // console.log(x, y, svgViewBoxMin);\n        }\n    });\n    const handleBackgroundMove = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        if (active === 'background') {\n            const { x, y } = getMousePosition(e);\n            dispatch(\n                setSvgViewBoxMin({\n                    x: svgViewBoxMinTmp.x + ((offset.x - x) * svgViewBoxZoom) / 100,\n                    y: svgViewBoxMinTmp.y + ((offset.y - y) * svgViewBoxZoom) / 100,\n                })\n            );\n            // console.log('move', active, { x: offset.x - x, y: offset.y - y }, svgViewBoxMin);\n        }\n    });\n    const handleBackgroundUp = useEvent((e: React.PointerEvent<SVGSVGElement>) => {\n        // when user holding the shift key and mis-click the background\n        // preserve the current selection\n        if (active === 'background' && !e.shiftKey) {\n            dispatch(setActive(undefined)); // svg mouse event only\n            // console.log('up', active);\n        }\n    });\n\n    // const [svgViewBoxZoom, setSvgViewBoxZoom] = React.useState(100);\n    const handleBackgroundWheel = useEvent((e: React.WheelEvent<SVGSVGElement>) => {\n        if (e.deltaY > 0 && svgViewBoxZoom + 10 < 400) dispatch(setSvgViewBoxZoom(svgViewBoxZoom + 10));\n        else if (e.deltaY < 0 && svgViewBoxZoom - 10 > 0) dispatch(setSvgViewBoxZoom(svgViewBoxZoom - 10));\n    });\n    const handleKeyDown = useEvent((e: React.KeyboardEvent<SVGSVGElement>) => {\n        // tabIndex need to be on the element to make onKeyDown worked\n        // https://www.delftstack.com/howto/react/onkeydown-react/\n        if (e.key === 'Delete') {\n            // remove all the selected nodes and edges\n            if (selected.length > 0) {\n                selected\n                    .filter(s => graph.current.hasNode(s) || graph.current.hasEdge(s))\n                    .forEach(s => {\n                        dispatch(clearSelected());\n                        graph.current.hasNode(s) ? graph.current.dropNode(s) : graph.current.dropEdge(s);\n                        refreshAndSave();\n                    });\n            }\n        } else if (e.key.startsWith('Arrow')) {\n            const d = 100;\n            const x_factor = e.key.endsWith('Left') ? -1 : e.key.endsWith('Right') ? 1 : 0;\n            const y_factor = e.key.endsWith('Up') ? -1 : e.key.endsWith('Down') ? 1 : 0;\n            dispatch(\n                setSvgViewBoxMin({\n                    x: svgViewBoxMin.x + ((d * svgViewBoxZoom) / 100) * x_factor,\n                    y: svgViewBoxMin.y + ((d * svgViewBoxZoom) / 100) * y_factor,\n                })\n            );\n        }\n    });\n\n    const size: Size = useWindowSize();\n    const height = (size.height ?? 1280) - 40;\n    const width = (size.width ?? 720) - 50;\n\n    return (\n        <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            id=\"canvas\"\n            height={height}\n            width={width}\n            viewBox={`${svgViewBoxMin.x} ${svgViewBoxMin.y} ${(width * svgViewBoxZoom) / 100} ${\n                (height * svgViewBoxZoom) / 100\n            } `}\n            onPointerDown={handleBackgroundDown}\n            onPointerMove={handleBackgroundMove}\n            onPointerUp={handleBackgroundUp}\n            onWheel={handleBackgroundWheel}\n            tabIndex={0}\n            onKeyDown={handleKeyDown}\n        >\n            <SvgCanvas />\n        </svg>\n    );\n};\n\nexport default SvgWrapper;\n","import { useState, useEffect } from 'react';\n\n// Define general type for useWindowSize hook, which includes width and height\nexport interface Size {\n    width: number | undefined;\n    height: number | undefined;\n}\n\n// Hook\nexport const useWindowSize = (): Size => {\n    // Initialize state with undefined width/height so server and client renders match\n    // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n    const [windowSize, setWindowSize] = useState<Size>({\n        width: undefined,\n        height: undefined,\n    });\n\n    useEffect(() => {\n        // Handler to call on window resize\n        function handleResize() {\n            // Set window width/height to state\n            setWindowSize({\n                width: window.innerWidth,\n                height: window.innerHeight,\n            });\n        }\n\n        // Add event listener\n        window.addEventListener('resize', handleResize);\n\n        // Call handler right away so state gets updated with initial window size\n        handleResize();\n\n        // Remove event listener on cleanup\n        return () => window.removeEventListener('resize', handleResize);\n    }, []); // Empty array ensures that effect is only run on mount\n\n    return windowSize;\n};\n","import { MultiDirectedGraph } from 'graphology';\nimport { NodeAttributes, EdgeAttributes, GraphAttributes } from '../constants/constants';\n\nexport const getMousePosition = (e: React.MouseEvent) => {\n    const bbox = e.currentTarget.getBoundingClientRect();\n    const x = e.clientX - bbox.left;\n    const y = e.clientY - bbox.top;\n    // console.log(e.clientX, bbox.left, e.clientY, bbox.top, x, y);\n    return { x, y };\n};\n\nexport const roundToNearestN = (x: number, n: number) => Math.round(x / n) * n;\n\nexport const calculateCanvasSize = (graph: MultiDirectedGraph<NodeAttributes, EdgeAttributes, GraphAttributes>) => {\n    let [xMin, yMin, xMax, yMax] = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE];\n\n    graph.forEachNode((node, attr) => {\n        xMin = Math.min(attr.x, xMin);\n        yMin = Math.min(attr.y, yMin);\n        xMax = Math.max(attr.x, xMax);\n        yMax = Math.max(attr.y, yMax);\n    });\n\n    xMin -= 150;\n    yMin -= 150;\n    xMax += 150;\n    yMax += 150;\n\n    return { xMin, yMin, xMax, yMax };\n};\n","import { useLayoutEffect, useRef } from \"react\";\n\ntype AnyFunction = (...args: any[]) => any;\n\n/**\n * Suppress the warning when using useLayoutEffect with SSR\n * https://reactjs.org/link/uselayouteffect-ssr\n */\nconst useBrowserLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : () => {};\n\n/**\n * Similar to useCallback, with a few subtle differences:\n * - The returned function is a stable reference, and will always be the same between renders\n * - No dependency lists required\n * - Properties or state accessed within the callback will always be \"current\"\n */\nexport function useEvent<TCallback extends AnyFunction>(callback: TCallback): TCallback {\n  // Keep track of the latest callback:\n  const latestRef = useRef<TCallback>(useEvent_shouldNotBeInvokedBeforeMount as any);\n  useBrowserLayoutEffect(() => {\n    latestRef.current = callback;\n  }, [callback]);\n\n  // Create a stable callback that always calls the latest callback:\n  const stableRef = useRef<TCallback>(null as any);\n  if (!stableRef.current) {\n    stableRef.current = function(this: any) {\n      return latestRef.current.apply(this, arguments as any);\n    } as TCallback;\n  }\n\n  return stableRef.current;\n}\n\n/**\n * Render methods should be pure, especially when concurrency is used,\n * so we will throw this error if the callback is called while rendering.\n */\nfunction useEvent_shouldNotBeInvokedBeforeMount() {\n  throw new Error(\n    \"INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.\"\n  );\n}\n\nexport default useEvent;\n","export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n"],"names":["edges","lines","miscEdges","graph","lineGroupToReconcile","linesNeedToReconcile","filterDirectedEdges","edge","attr","source","target","sourceAttr","targetAttr","undirected","startsWith","reconcileId","lineNeedReconcile","getEdgeAttribute","push","getAllLinesNeedToReconcile","allReconciledLines","danglingLines","Object","values","forEach","length","every","line","generatePath","count","sources","Set","targets","extremities","fromEntries","map","add","source_","Array","from","filter","s","target_","t","reconciledLines","currentNode","i","currentTarget","at","generateReconciledPath","reconciledLine","hasEdge","paths","getNodeAttributes","type","defaultAttrs","x","y","path","d","replace","roundPathCorners","getStations","filterNodes","node","visible","zIndex","getLines","getEdgeAttributes","x1","y1","x2","y2","getMiscNodes","getMiscEdges","EDGES","allLines","dispatch","useRootDispatch","useRootSelector","state","runtime","selected","refresh","refreshAll","all","reconcileLine","mode","active","theme","svgViewBoxZoom","app","refreshAndSave","setRefresh","saveGraph","current","export","React","window","offset","setOffset","newLinePosition","setNewLinePosition","handlePointerDown","useEvent","e","stopPropagation","el","getMousePosition","setPointerCapture","pointerId","setActive","shiftKey","clearSelected","addSelected","handlePointerMove","updateNodeAttributes","roundToNearestN","altKey","handlePointerUp","setMode","prefix","id","document","elementsFromPoint","clientX","clientY","attributes","getNamedItem","value","slice","newLineId","nanoid","addDirectedEdgeWithKey","color","JSON","parse","stringify","undefined","handleEdgeClick","stations","setStations","setLines","nodes","setNodes","setEdges","setAllReconciledLines","setDanglingLines","reconcileLines","DrawLineComponent","component","props","LineComponent","LineType","newLine","attrs","handleClick","fill","stroke","strokeWidth","strokeLinejoin","join","n","MiscNodeComponent","miscNodes","EdgeComponent","station","StationComponent","allStations","getNodeAttribute","svgViewBoxMin","svgViewBoxMinTmp","setSvgViewBoxMinTmp","handleBackgroundDown","rand","addNode","handleBackgroundMove","setSvgViewBoxMin","handleBackgroundUp","handleBackgroundWheel","deltaY","setSvgViewBoxZoom","handleKeyDown","key","hasNode","dropNode","dropEdge","x_factor","endsWith","y_factor","size","useState","width","height","windowSize","setWindowSize","useEffect","handleResize","innerWidth","innerHeight","addEventListener","removeEventListener","useWindowSize","xmlns","viewBox","onPointerDown","onPointerMove","onPointerUp","onWheel","tabIndex","onKeyDown","bbox","getBoundingClientRect","left","top","Math","round","calculateCanvasSize","Number","MAX_VALUE","MIN_VALUE","xMin","yMin","xMax","yMax","forEachNode","min","max","useBrowserLayoutEffect","react_1","callback","latestRef","useEvent_shouldNotBeInvokedBeforeMount","stableRef","apply","this","arguments","Error","exports","crypto","getRandomValues","Uint8Array","reduce","byte","toString","toUpperCase"],"sourceRoot":""}