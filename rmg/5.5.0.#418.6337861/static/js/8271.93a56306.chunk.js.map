{"version":3,"file":"static/js/8271.93a56306.chunk.js","mappings":"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","sources":["svgs/railmap/main/loop/loop-coline-shmetro.tsx","svgs/railmap/main/loop/loop-shmetro.tsx","svgs/railmap/methods/shmetro-loop.ts"],"sourcesContent":["import { useRootSelector } from '../../../../redux';\nimport { isColineBranch } from '../../../../redux/param/coline-action';\nimport { CanvasType } from '../../../../constants/constants';\n\nexport const LoopColine = (props: {\n    edges: [number, number, number, number];\n    loop_stns: {\n        top: string[];\n        left: string[];\n        right: string[];\n        bottom: string[];\n    };\n    xs: {\n        [stn_id: string]: number;\n    };\n    ys: {\n        [stn_id: string]: number;\n    };\n    canvas: CanvasType.RailMap | CanvasType.Indoor;\n}) => {\n    const { edges, loop_stns, xs, ys, canvas } = props;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [X_LEFT, X_RIGHT, Y_TOP, Y_BOTTOM] = edges;\n    const { info_panel_type, stn_list, coline } = useRootSelector(store => store.param);\n\n    const { branches } = useRootSelector(store => store.helper);\n\n    // find the coline color on the main/loop line\n    const coline_main_color = Object.values(coline)\n        .filter(co =>\n            [co.from, co.to].every(stn_id =>\n                branches\n                    .slice(1, 3)\n                    .filter(branch => isColineBranch(branch, stn_list))\n                    .flat()\n                    .includes(stn_id)\n            )\n        )\n        .map(co => co.colors)\n        .at(0); // only one coline in loop line is supported\n\n    const LINE_WIDTH = 12;\n    const COLINE_GAP = canvas === CanvasType.RailMap && info_panel_type === 'sh2020' ? 3 : 0;\n    return (\n        <g id=\"coline_main\">\n            <path d={`M ${X_LEFT},${Y_TOP} H${X_RIGHT}`} strokeWidth={12} stroke={coline_main_color?.at(0)?.at(2)} />\n            {\n                // additional station cover on the rail map\n                canvas === CanvasType.RailMap &&\n                    Object.keys(coline).length > 0 &&\n                    loop_stns.top.map(stn_id => (\n                        <g key={stn_id} transform={`translate(${xs[stn_id]},${ys[stn_id]})`}>\n                            {info_panel_type === 'sh2020' ? (\n                                <>\n                                    <rect\n                                        stroke=\"none\"\n                                        height={24}\n                                        width={12}\n                                        x={-6}\n                                        y={-COLINE_GAP - 1}\n                                        fill={coline_main_color?.at(0)?.at(2)}\n                                    />\n                                    <rect\n                                        stroke=\"none\"\n                                        height={COLINE_GAP + LINE_WIDTH}\n                                        width={12}\n                                        x={-6}\n                                        y={LINE_WIDTH - 2}\n                                        fill=\"var(--rmg-theme-colour)\"\n                                    />\n                                </>\n                            ) : (\n                                <use\n                                    xlinkHref=\"#int2_sh\"\n                                    stroke=\"var(--rmg-theme-colour)\"\n                                    transform={`translate(0,${1 + LINE_WIDTH})`}\n                                />\n                            )}\n                        </g>\n                    ))\n            }\n        </g>\n    );\n};\n","import React from 'react';\nimport StationSHMetro from '../station/station-shmetro';\nimport { NameDirection, StationSHMetro as StationSHMetroIndoor } from '../../../indoor/station-shmetro';\nimport { CanvasType, Services, ShortDirection } from '../../../../constants/constants';\nimport { useRootSelector } from '../../../../redux';\nimport { isColineBranch } from '../../../../redux/param/coline-action';\nimport {\n    get_xshares_yshares_of_loop,\n    LoopStns,\n    split_loop_stns,\n    split_loop_stns_with_branch,\n    split_loop_stns_with_branches,\n} from '../../methods/shmetro-loop';\nimport { get_loop_branches, LoopBranches } from './loop-branches-shmetro';\nimport { LoopColine } from './loop-coline-shmetro';\n\nconst LoopSHMetro = (props: { bank_angle: boolean; canvas: CanvasType.RailMap | CanvasType.Indoor }) => {\n    const { bank_angle, canvas } = props;\n    const { branches } = useRootSelector(store => store.helper);\n    const {\n        current_stn_idx: current_stn_id,\n        svgWidth: svg_width,\n        svg_height,\n        padding,\n        branchSpacingPct,\n        direction,\n        info_panel_type,\n        stn_list,\n        loop_info: { left_and_right_factor, bottom_factor },\n        coline,\n    } = useRootSelector(store => store.param);\n\n    const loopline = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const branch_stn_ids = branches\n        .slice(0, 3) // drop additional branches\n        .flat()\n        .filter(\n            (\n                o => v =>\n                    (o[v] = (o[v] || 0) + 1) === 2\n            )({} as { [stn_id: string]: number })\n        ) // count each occurrence\n        .filter(stn_id => !['linestart', 'lineend'].includes(stn_id)); // find branch stations\n\n    // find which arc would be displayed on the top side from coline info\n    const arc =\n        Object.values(coline)\n            .filter(co =>\n                [co.from, co.to].every(stn_id =>\n                    branches\n                        .slice(1, 3)\n                        .filter(branch => isColineBranch(branch, stn_list))\n                        .flat()\n                        .includes(stn_id)\n                )\n            )\n            .map(co => {\n                const from_idx = loopline.findIndex(stn_id => stn_id === co.from);\n                const to_idx = loopline.findIndex(stn_id => stn_id === co.to);\n                return Math.abs(to_idx - from_idx) > loopline.length - 2 - Math.abs(to_idx - from_idx)\n                    ? 'major'\n                    : 'minor';\n            })\n            .at(0) ?? 'minor';\n\n    // use different split methods for different numbers of branches\n    const loop_stns = branch_stn_ids.at(1)\n        ? split_loop_stns_with_branches(loopline, branch_stn_ids as [string, string], left_and_right_factor, arc)\n        : branch_stn_ids.at(0)\n        ? split_loop_stns_with_branch(loopline, branch_stn_ids[0], bottom_factor, left_and_right_factor)\n        : split_loop_stns(loopline, current_stn_id, bottom_factor, left_and_right_factor);\n    const { x_shares: x_shares_loop, y_shares: y_shares_loop } = get_xshares_yshares_of_loop(loopline, loop_stns);\n\n    // calculate xs and ys for branches\n    const { loop_branches, line_xs_branches, xs_branches } = get_loop_branches(\n        branches,\n        branch_stn_ids,\n        svg_width[canvas],\n        padding,\n        left_and_right_factor,\n        loop_stns.bottom.length // respect to the new bottom_factor if there are 2 branches for critical_path_length\n    );\n\n    // all y_shares in branches will be 0\n    const y_shares = { ...y_shares_loop, ...Object.fromEntries(loop_branches.flat().map(stn => [stn, 0])) };\n    // before: branch_spacing / 400 * svg_height (Chito)\n    const verticalPadding = (branchSpacingPct * svg_height) / 300;\n    const line_ys = [\n        225 + verticalPadding,\n        svg_height - 75 - (canvas === CanvasType.RailMap ? 0 : 125) - verticalPadding,\n    ] as [number, number];\n    const ys = Object.keys(y_shares).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: line_ys[0] + y_shares[cur] * (line_ys[1] - line_ys[0]),\n        }),\n        {} as typeof y_shares\n    );\n    const line_xs = [\n        // in railmap and bank, we need to add extra padding for the 45-degree angle\n        // also if there are branches, we need to leave additional spaces\n        Math.max(\n            (svg_width[canvas] * padding) / 100 + (bank_angle && canvas === CanvasType.RailMap ? 100 : 0),\n            line_xs_branches[0]\n        ),\n        Math.min(\n            svg_width[canvas] * (1 - padding / 100) - (bank_angle && canvas === CanvasType.RailMap ? 100 : 0),\n            line_xs_branches[1]\n        ),\n    ] as [number, number];\n    const xs_loop = Object.keys(x_shares_loop).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: line_xs[0] + x_shares_loop[cur] * (line_xs[1] - line_xs[0]),\n        }),\n        {} as typeof x_shares_loop\n    );\n\n    // bank the right, bottom, left side if bank_angle\n    const bank = (bank_angle ? { l: 1, r: -1 }[direction] : 0) as -1 | 0 | 1;\n    [...loop_stns.right, ...loop_stns.left].forEach(stn_id => {\n        xs_loop[stn_id] -= (ys[stn_id] - line_ys[0]) * bank;\n    });\n    loop_stns.bottom.forEach(stn_id => {\n        xs_loop[stn_id] -= (line_ys[1] - line_ys[0]) * bank;\n    });\n\n    const xs = { ...xs_branches, ...xs_loop };\n\n    // generate loop path used in svg\n    const path = _linePath(loop_stns, xs, ys, bank, [...line_xs, ...line_ys], direction);\n\n    // coline stuff\n    const LINE_WIDTH = 12;\n    const COLINE_GAP = canvas === CanvasType.RailMap && info_panel_type === 'sh2020' ? 3 : 0;\n    // move up to display the full station name and int\n    if (Object.keys(coline).length > 0) {\n        loop_stns.top.forEach(stn_id => {\n            ys[stn_id] -= COLINE_GAP + LINE_WIDTH;\n        });\n    }\n\n    // FIXME: branches with only one station could not display properly\n    const dy = loop_branches.length ? 0 : ((line_ys[1] - line_ys[0]) * bank) / 2;\n    return (\n        <g id=\"loop\" transform={`translate(${dy},0)`}>\n            <path stroke=\"var(--rmg-theme-colour)\" strokeWidth={12} fill=\"none\" d={path} strokeLinejoin=\"round\" />\n            {/* Order matters. The LoopColine should cover the station in RailMap. */}\n            {canvas === CanvasType.RailMap && (\n                <LoopStationGroup canvas={canvas} loop_stns={loop_stns} xs={xs} ys={ys} />\n            )}\n            <g transform={`translate(0,${Object.keys(coline).length > 0 ? -LINE_WIDTH - COLINE_GAP : 0})`}>\n                <LoopBranches\n                    loop_branches={loop_branches}\n                    edges={[...line_xs, ...line_ys]}\n                    xs={xs}\n                    ys={ys}\n                    canvas={canvas}\n                />\n                {Object.keys(coline).length > 0 && (\n                    <LoopColine\n                        edges={[...line_xs, ...line_ys]}\n                        loop_stns={loop_stns}\n                        xs={xs}\n                        ys={ys}\n                        canvas={canvas}\n                    />\n                )}\n            </g>\n            {/* Order matters. The station should cover LoopColine's main path in Indoor. */}\n            {canvas === CanvasType.Indoor && <LoopStationGroup canvas={canvas} loop_stns={loop_stns} xs={xs} ys={ys} />}\n        </g>\n    );\n};\n\nexport default LoopSHMetro;\n\nexport const _linePath = (\n    loop_stns: LoopStns,\n    xs: { [stn_id: string]: number },\n    ys: { [stn_id: string]: number },\n    bank: -1 | 0 | 1,\n    // use these edges to mock when there is no station on the edge\n    edges: [number, number, number, number],\n    direction: ShortDirection\n) => {\n    const [X_LEFT, X_RIGHT, Y_TOP, Y_BOTTOM] = edges;\n\n    // calculate the corner point when two sides needs to be joined\n    const corner = (prev_x: number, prev_y: number, x: number, y: number, side: keyof LoopStns): [number, number] => {\n        return {\n            right: [x + (y - Y_TOP) * bank, prev_y] as [number, number],\n            bottom: [prev_x - (Y_BOTTOM - prev_y) * bank, y] as [number, number],\n            left: [x - (Y_BOTTOM - y) * bank, prev_y] as [number, number],\n            top: [prev_x + (prev_y - Y_TOP) * bank, y] as [number, number],\n        }[side];\n    };\n\n    const stn_pos = [] as [number, number][];\n    loop_stns.top.forEach(stn_id => {\n        stn_pos.push([xs[stn_id], ys[stn_id]]);\n    });\n    (['right', 'bottom', 'left'] as Exclude<keyof LoopStns, 'top'>[]).forEach(side => {\n        if (loop_stns[side].length > 0) {\n            stn_pos.push(\n                corner(stn_pos.at(-1)![0], stn_pos.at(-1)![1], xs[loop_stns[side][0]], ys[loop_stns[side][0]], side)\n            );\n            loop_stns[side].forEach(stn_id => {\n                stn_pos.push([xs[stn_id], ys[stn_id]]);\n            });\n        } else {\n            // simulate a fake station on the side\n            // this station lays on the previous side corner\n            const extra = {\n                right: [X_RIGHT, stn_pos.at(-1)![1]] as [number, number],\n                bottom: [\n                    stn_pos.at(-1)![0] + (Y_BOTTOM - stn_pos.at(-1)![1]) * -bank,\n                    stn_pos.at(-1)![1] + (Y_BOTTOM - stn_pos.at(-1)![1]),\n                ] as [number, number],\n                left: [\n                    X_LEFT + (bank === 0 ? 0 : (Y_BOTTOM - Y_TOP) * (direction === 'l' ? -1 : 1)),\n                    stn_pos.at(-1)![1],\n                ] as [number, number],\n            };\n            stn_pos.push(extra[side]);\n        }\n    });\n    stn_pos.push(corner(stn_pos.at(-1)![0], stn_pos.at(-1)![1], xs[loop_stns.top[0]], ys[loop_stns.top[0]], 'top'));\n\n    const path = stn_pos\n        .slice(1)\n        .map(([x, y]) => `L${x},${y} `)\n        .join(' ');\n    return `M${stn_pos[0][0]},${stn_pos[0][1]} ${path} Z`;\n};\n\nconst LoopStationGroup = (props: {\n    canvas: CanvasType.RailMap | CanvasType.Indoor;\n    loop_stns: LoopStns;\n    xs: {\n        [k: string]: number;\n    };\n    ys: {\n        [k: string]: number;\n    };\n}) => {\n    const { canvas, loop_stns, xs, ys } = props;\n    const { current_stn_idx: current_stn_id } = useRootSelector(store => store.param);\n\n    const railmap_bank: Record<keyof LoopStns, -1 | 0 | 1> = {\n        top: 0,\n        bottom: 0,\n        left: -1,\n        right: 1,\n    };\n    const railmap_direction: Record<keyof LoopStns, 'l' | 'r' | undefined> = {\n        left: 'r',\n        right: 'l',\n        top: undefined,\n        bottom: undefined,\n    };\n    const indoor_name_direction = (side: keyof LoopStns, i: number) =>\n        ({\n            top: i % 2 === 0 ? 'upward' : 'downward',\n            bottom: i % 2 === 0 ? 'upward' : 'downward',\n            left: 'left',\n            right: 'right',\n        }[side] as NameDirection);\n    return (\n        <g id=\"loop_stations\">\n            {canvas === CanvasType.RailMap &&\n                Object.entries(loop_stns).map(([side, stn_ids]) =>\n                    stn_ids.map(stn_id => (\n                        <g key={stn_id} transform={`translate(${xs[stn_id]},${ys[stn_id]})`}>\n                            <StationSHMetro\n                                stnId={stn_id}\n                                stnState={current_stn_id === stn_id ? 0 : 1}\n                                bank={railmap_bank[side as keyof LoopStns]}\n                                direction={railmap_direction[side as keyof LoopStns]}\n                            />\n                        </g>\n                    ))\n                )}\n            {canvas === CanvasType.Indoor &&\n                Object.entries(loop_stns).map(([side, stn_ids]) =>\n                    stn_ids.map((stn_id, i) => (\n                        <g key={stn_id} transform={`translate(${xs[stn_id]},${ys[stn_id]})`}>\n                            <StationSHMetroIndoor\n                                stnId={stn_id}\n                                nameDirection={indoor_name_direction(side as keyof LoopStns, i)}\n                                services={[Services.local]}\n                            />\n                        </g>\n                    ))\n                )}\n        </g>\n    );\n};\n","import { ShortDirection, StationDict } from '../../../constants/constants';\n\n/**\n * Split the loopline into four sides according to left_and_right_factor and bottom_factor.\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param current_stn_id Current station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns = (\n    loopline: string[],\n    current_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const current_stn_idx = loopline.findIndex(val => val === current_stn_id);\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + current_stn_idx - Math.floor(top_factor / 2) + (top_factor % 2 === 0 ? 1 : 0);\n    const split_b = loopline.length + current_stn_idx + Math.floor(top_factor / 2);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with one branch into four sides according to left_and_right_factor and bottom_factor.\n * Note that the top side must start from the branch_stn_id.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_id Branch station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branch = (\n    loopline: string[],\n    branch_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + loopline.findIndex(val => val === branch_stn_id);\n    const another_branch_stn_id = non_undefined_loopline[split_a + top_factor - 1];\n    const split_b =\n        loopline.length +\n        loopline.findIndex(val => val === another_branch_stn_id) +\n        (split_a + top_factor > loopline.length * 2 ? loopline.length : 0);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with two branches into four sides according to left_and_right_factor and arc.\n * Note that the top side must start from one of the branch_stn_ids and end at another.\n * Also the top side will be the major or the minor arc between branch_stn_ids.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > the major or the minor arc length between branch_stn_ids +\n *                          left_and_right_factor * 2\n *     2. left_and_right_factor >= 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_ids Branches station id.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @param arc Which arc will be the top side, the major or the minor.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branches = (\n    loopline: string[],\n    branch_stn_ids: [string, string],\n    left_and_right_factor: number,\n    arc: 'major' | 'minor'\n) => {\n    let split_a = loopline.findIndex(val => val === branch_stn_ids[0]);\n    let split_b = loopline.findIndex(val => val === branch_stn_ids[1]);\n    // swap a and b if a is bigger than b\n    [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]] =\n        split_a > split_b\n            ? [split_b, split_a, branch_stn_ids[1], branch_stn_ids[0]]\n            : [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]];\n    const top_a = loopline.slice(split_a, split_b + 1);\n    const top_b = loopline.filter(stn => !top_a.filter(stn => !branch_stn_ids.includes(stn)).includes(stn));\n    // which arc we use on the top will result to different bottom factor\n    const bottom_factor =\n        loopline.length -\n        (arc === 'major' ? Math.max : Math.min)(top_a.length, top_b.length) -\n        left_and_right_factor * 2;\n    const branch_stn_id =\n        arc === 'major'\n            ? top_a.length > top_b.length\n                ? branch_stn_ids[0]\n                : branch_stn_ids[1]\n            : top_a.length > top_b.length\n            ? branch_stn_ids[1]\n            : branch_stn_ids[0];\n    return split_loop_stns_with_branch(loopline, branch_stn_id, bottom_factor, left_and_right_factor);\n};\n\nexport type LoopStns = ReturnType<typeof split_loop_stns>;\n\n/**\n * Calculate the xshares and yshares of the loop stations.\n *\n * @param loopline The loop line aka branches[0].\n * @param loop_stns Object returned from split_loop_stns.\n * @returns Values sit between 0 and 1.\n */\nexport const get_xshares_yshares_of_loop = (loopline: string[], loop_stns: LoopStns) => {\n    const x_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n    const y_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n\n    const [Y_TOP, Y_BOTTOM, X_LEFT, X_RIGHT] = [0, 1, 0, 1];\n\n    // loop's inner padding for xs\n    const e = 0; // 0 <= e <= 1\n\n    loop_stns.top.forEach((stn_id, i) => {\n        x_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.top.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_TOP;\n    });\n    loop_stns.right.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_RIGHT;\n        y_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.right.length + 1)) * (i + 1);\n    });\n    loop_stns.bottom.forEach((stn_id, i) => {\n        x_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.bottom.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_BOTTOM;\n    });\n    loop_stns.left.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_LEFT;\n        y_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.left.length + 1)) * (i + 1);\n    });\n\n    return {\n        x_shares: x_shares,\n        y_shares: y_shares,\n    };\n};\n\n/**\n * Get pivot stations from the loop line.\n */\nexport const get_pivot_stations = (\n    branches: string[][],\n    direction: ShortDirection,\n    stn_list: StationDict,\n    current_stn_id: string\n) => {\n    const loop_line = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const _ = [...loop_line, ...loop_line, ...loop_line];\n    const non_undefined_loop_line = direction === 'r' ? _ : _.reverse();\n    const current_stn_idx = non_undefined_loop_line.findIndex(stn_id => current_stn_id === stn_id) + loop_line.length;\n    return non_undefined_loop_line\n        .slice(current_stn_idx + 1)\n        .filter(stn_id => stn_list[stn_id].loop_pivot)\n        .slice(undefined, 2);\n};\n"],"names":["LoopColine","props","edges","loop_stns","xs","ys","canvas","X_LEFT","X_RIGHT","Y_TOP","useRootSelector","store","param","info_panel_type","stn_list","coline","branches","helper","coline_main_color","Object","values","filter","co","from","to","every","stn_id","slice","branch","isColineBranch","flat","includes","map","colors","at","COLINE_GAP","CanvasType","id","d","strokeWidth","stroke","keys","length","top","transform","height","width","x","y","fill","LINE_WIDTH","xlinkHref","o","bank_angle","current_stn_id","current_stn_idx","svg_width","svgWidth","svg_height","padding","branchSpacingPct","direction","loop_info","left_and_right_factor","bottom_factor","loopline","branch_stn_ids","v","arc","from_idx","findIndex","to_idx","Math","abs","split_loop_stns_with_branches","split_loop_stns_with_branch","split_loop_stns","get_xshares_yshares_of_loop","x_shares_loop","x_shares","y_shares_loop","y_shares","get_loop_branches","bottom","loop_branches","line_xs_branches","xs_branches","fromEntries","stn","verticalPadding","line_ys","reduce","acc","cur","line_xs","max","min","xs_loop","bank","l","r","right","left","forEach","path","_linePath","dy","strokeLinejoin","LoopStationGroup","LoopBranches","Y_BOTTOM","corner","prev_x","prev_y","side","stn_pos","push","extra","join","railmap_bank","railmap_direction","undefined","indoor_name_direction","i","entries","stnId","stnState","StationSHMetro","nameDirection","services","Services","top_factor","val","non_undefined_loopline","split_a","floor","split_b","branch_stn_id","another_branch_stn_id","top_a","top_b","e","get_pivot_stations","loop_line","_","non_undefined_loop_line","reverse","loop_pivot"],"sourceRoot":""}