{"version":3,"file":"static/js/8097.fb45e25d.chunk.js","mappings":"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","sources":["svgs/railmap/main/coline/coline-shmetro.tsx","svgs/railmap/main/main-shmetro.tsx","svgs/railmap/methods/shmetro-coline.ts"],"sourcesContent":["import React from 'react';\nimport { drawLine } from '../../methods/share';\nimport { calculateColine, calculateColineStations } from '../../methods/shmetro-coline';\nimport { AtLeastOneOfPartial, InterchangeInfo, Services } from '../../../../constants/constants';\nimport { useRootSelector } from '../../../../redux';\nimport { _linePath, StationGroupProps } from '../main-shmetro';\nimport StationSHMetro from '../station/station-shmetro';\n\ninterface Props {\n    xs: { [stnId: string]: number };\n    servicesPresent: Services[];\n    stnStates: { [stnId: string]: -1 | 0 | 1 };\n}\n\ninterface ColineServicesPath {\n    main: {\n        path: string;\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        path: string;\n        colors: InterchangeInfo[];\n    }[];\n    service: Services;\n}\n\ntype ColinePath = AtLeastOneOfPartial<Record<Services, ColineServicesPath>>;\nconst defaultTheme = ['shanghai', 'sh4', '#5F259F', '#fff', '4号线', 'Line 4'] as InterchangeInfo;\n\nexport const ColineSHMetro = (props: Props) => {\n    const { xs, servicesPresent, stnStates } = props;\n\n    const {\n        svg_height,\n        direction,\n        stn_list,\n        current_stn_idx,\n        branchSpacingPct,\n        info_panel_type,\n        coline: colineInfo,\n    } = useRootSelector(store => store.param);\n    const { branches, depsStr: deps } = useRootSelector(store => store.helper);\n\n    const yShares = React.useMemo(\n        () => {\n            console.log('computing y shares');\n            return Object.keys(stn_list).reduce((acc, cur) => {\n                if (branches[0].includes(cur)) {\n                    return { ...acc, [cur]: 0 };\n                } else {\n                    const branchOfStn = branches.slice(1).filter(branch => branch.includes(cur))[0];\n                    return { ...acc, [cur]: stn_list[branchOfStn[0]].children.indexOf(branchOfStn[1]) ? -3 : 3 };\n                }\n            }, {} as { [stnId: string]: number });\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps]\n    );\n    // filter out all positive yShares to draw the railmap w/ coline and its branches\n    const colineYShares = Object.entries(yShares)\n        .filter(([k, v]) => v <= 0)\n        .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {} as typeof yShares);\n    const colineYs = Object.keys(colineYShares).reduce(\n        (acc, cur) => ({ ...acc, [cur]: (-colineYShares[cur] * branchSpacingPct * svg_height) / 300 }),\n        {} as typeof yShares\n    );\n\n    // coline color and all stations in the coline segments\n    const colineStns = React.useMemo(\n        () =>\n            calculateColine(\n                calculateColineStations(\n                    Object.values(colineInfo).filter(co => co.display),\n                    branches\n                ),\n                stnStates\n            ),\n        [JSON.stringify(colineInfo), current_stn_idx, direction, deps]\n    );\n\n    const colinePaths = servicesPresent.reduce(\n        (acc, service) => ({\n            ...acc,\n            [service]: (Object.keys(colineStns) as (keyof ReturnType<typeof drawLine>)[]).reduce(\n                (acc, cur) => ({\n                    ...acc,\n                    [cur]: colineStns[cur]\n                        .map(colineStn => ({\n                            path: _linePath(\n                                colineStn.linePath,\n                                cur,\n                                xs,\n                                colineYs,\n                                direction,\n                                service,\n                                servicesPresent.length,\n                                stn_list,\n                                'diagonal'\n                            ),\n                            colors: colineStn.colors,\n                        }))\n                        .filter(colineStn => colineStn.path !== ''),\n                }),\n                {} as ColineServicesPath\n            ),\n        }),\n        {} as ColinePath\n    );\n\n    // only display coline stations when coline in effect\n    const colineStations = calculateColineStations(\n        Object.values(colineInfo).filter(co => co.display),\n        branches\n    )\n        .map(co => co.linePath)\n        .flat();\n\n    const LINE_WIDTH = 12;\n    const COLINE_GAP = info_panel_type === 'sh2020' ? 3 : 0;\n    return (\n        <>\n            <g id=\"coline\" transform={`translate(0,${LINE_WIDTH + COLINE_GAP})`}>\n                <CoLine paths={colinePaths} direction={direction} />\n                <ColineStationInMainLine\n                    colineStns={colineStns}\n                    branches={branches}\n                    xs={xs}\n                    ys={colineYs}\n                    stnStates={stnStates}\n                    lineWidth={LINE_WIDTH}\n                    colineGap={COLINE_GAP}\n                />\n                <ColineStationGroup\n                    stnIds={Object.entries(yShares)\n                        .filter(([k, v]) => v < 0)\n                        .reduce((acc, [k, v]) => [...acc, k], [] as string[])\n                        .filter(stnId => !['linestart', 'lineend'].includes(stnId))\n                        .filter(stnId => stn_list[stnId].services.length !== 0)\n                        .filter(stnId => colineStations.includes(stnId))}\n                    xs={xs}\n                    ys={colineYs}\n                    stnStates={stnStates}\n                />\n            </g>\n        </>\n    );\n};\n\nexport default ColineSHMetro;\n\nconst CoLine = (props: { paths: ColinePath; direction: 'l' | 'r' }) => {\n    const { paths, direction } = props;\n\n    return (\n        <>\n            {(Object.keys(paths) as Services[]).map((service, i) => (\n                <g key={`servicePath${i}`} transform={`translate(0,${i * 25})`}>\n                    <g>\n                        {paths[service]?.pass.map((colinePath, j) => (\n                            <React.Fragment key={j}>\n                                <path\n                                    key={j}\n                                    stroke=\"var(--rmg-grey)\"\n                                    strokeWidth={12}\n                                    fill=\"none\"\n                                    d={colinePath.path}\n                                    strokeLinejoin=\"round\"\n                                    filter={service === Services.local ? undefined : `url(#contrast-${service})`}\n                                />\n                            </React.Fragment>\n                        ))}\n\n                        {paths[service]?.main.map((colinePath, j) => (\n                            <React.Fragment key={j}>\n                                {colinePath.colors.length > 1 && (\n                                    <linearGradient\n                                        id={`grad${j}`}\n                                        y1=\"-100%\"\n                                        y2=\"100%\"\n                                        x1=\"0\"\n                                        x2=\"0\"\n                                        // gradientTransform=\"rotate(90)\"\n                                        gradientUnits=\"userSpaceOnUse\"\n                                    >\n                                        {colinePath.colors.map((color, i) => (\n                                            <React.Fragment key={i}>\n                                                {/* more about React.Fragment on https://stackoverflow.com/a/59390967 */}\n                                                <stop // from\n                                                    offset={`${(100 / colinePath.colors.length) * (i + 0)}%`}\n                                                    stopColor={color[2]}\n                                                />\n                                                <stop // to\n                                                    offset={`${(100 / colinePath.colors.length) * (i + 1)}%`}\n                                                    stopColor={color[2]}\n                                                />\n                                            </React.Fragment>\n                                        ))}\n                                    </linearGradient>\n                                )}\n\n                                {direction === 'l' && (\n                                    <marker\n                                        id={`arrow_left_${j}_${colinePath.colors.map(c => c[2]).join('_')}`}\n                                        refY={0.5}\n                                        refX={1}\n                                    >\n                                        <path\n                                            d=\"M1,0L0,1H1z\"\n                                            fill={\n                                                colinePath.colors.length > 1\n                                                    ? `url(#grad${j})`\n                                                    : colinePath.colors[0][2]\n                                            }\n                                        />\n                                    </marker>\n                                )}\n                                {direction === 'r' && (\n                                    <marker\n                                        id={`arrow_right_${j}_${colinePath.colors.map(c => c[2]).join('_')}`}\n                                        refY={0.5}\n                                    >\n                                        <path\n                                            d=\"M0,0L1,1H-1z\"\n                                            fill={\n                                                colinePath.colors.length > 1\n                                                    ? `url(#grad${j})`\n                                                    : colinePath.colors[0][2]\n                                            }\n                                        />\n                                    </marker>\n                                )}\n\n                                <path\n                                    key={j}\n                                    // stroke={colinePath.colors.length > 1 ? `url(#grad${j})` : colinePath.colors[0][2]}\n                                    stroke={(colinePath.colors.at(-1) ?? defaultTheme)[2]}\n                                    strokeWidth={12}\n                                    fill=\"none\"\n                                    d={colinePath.path}\n                                    markerStart={\n                                        direction === 'l'\n                                            ? `url(#arrow_left_${j}_${colinePath.colors.map(c => c[2]).join('_')})`\n                                            : undefined\n                                    }\n                                    markerEnd={\n                                        direction === 'r'\n                                            ? `url(#arrow_right_${j}_${colinePath.colors.map(c => c[2]).join('_')})`\n                                            : undefined\n                                    }\n                                    strokeLinejoin=\"round\"\n                                    filter={service === Services.local ? undefined : `url(#contrast-${service})`}\n                                />\n                            </React.Fragment>\n                        ))}\n                    </g>\n                </g>\n            ))}\n        </>\n    );\n};\n\ninterface ColineStationInMainLineProps {\n    colineStns: ReturnType<typeof calculateColine>;\n    branches: string[][];\n    xs: { [stnId: string]: number };\n    ys: { [stnId: string]: number };\n    stnStates: { [stnId: string]: -1 | 0 | 1 };\n    lineWidth: number;\n    colineGap: number;\n}\n\n/**\n * A small rect overlay on the main branch where coline is present.\n */\nconst ColineStationInMainLine = (props: ColineStationInMainLineProps) => {\n    const { colineStns, branches, xs, ys, stnStates, lineWidth: LINE_WIDTH, colineGap: COLINE_GAP } = props;\n    const { line_name, theme, info_panel_type } = useRootSelector(store => store.param);\n\n    // data to draw the station elements.\n    const colineStations = [...colineStns.main, ...colineStns.pass]\n        // Merge main and pass station together to minimize the code duplication\n        // and its state can obtained by stnStates.\n        .map(stns =>\n            stns.linePath.map(stnId => ({\n                curStn: stnId,\n                x: xs[stnId],\n                y: ys[stnId],\n                color: stns.colors.at(-1) ?? [...theme, ...line_name],\n            }))\n        )\n        .flat()\n        .reduce(\n            // remove current station as it appears in both main and pass\n            (acc, cur) => (acc.find(x => x.curStn === cur.curStn) ? acc : acc.concat(cur)),\n            [] as {\n                curStn: string;\n                x: number;\n                y: number;\n                color: InterchangeInfo;\n            }[]\n        )\n        // only take the coline stations in the first branch(general main line)\n        // as coline stations in lower branches will be taken care by ColineStationGroup\n        .filter(stn => branches[0].includes(stn.curStn));\n    console.log(colineStations);\n\n    return (\n        <g id=\"stations_in_mainline\">\n            {colineStations.map(colineStation => {\n                const { curStn, x, y, color } = colineStation;\n                const height = (stnStates[curStn] === -1 ? 0 : LINE_WIDTH) + COLINE_GAP + LINE_WIDTH;\n                const dy = (stnStates[curStn] === -1 ? 0 : -LINE_WIDTH) - COLINE_GAP - LINE_WIDTH / 2;\n                return (\n                    <g key={curStn} transform={`translate(${x},${y})`}>\n                        {info_panel_type === 'sh2020' ? (\n                            <rect\n                                stroke=\"none\"\n                                height={height}\n                                width={12}\n                                x={-6}\n                                y={dy}\n                                fill={stnStates[curStn] === -1 ? 'var(--rmg-grey)' : color[2]}\n                            />\n                        ) : (\n                            <use\n                                xlinkHref=\"#int2_sh\"\n                                stroke=\"var(--rmg-theme-colour)\"\n                                transform={`translate(0,${-LINE_WIDTH})`}\n                            />\n                        )}\n                    </g>\n                );\n            })}\n        </g>\n    );\n};\n\n/**\n * Complete station component for stations in lower branches.\n */\nconst ColineStationGroup = (props: StationGroupProps) => {\n    const { xs, ys, stnStates, stnIds } = props;\n    const { branches, depsStr: deps } = useRootSelector(store => store.helper);\n    const { line_name, theme, coline } = useRootSelector(store => store.param);\n\n    // get colors of stations in coline branches, they use different colors than var(--rmg-theme-colour)\n    const colines = React.useMemo(\n        () => calculateColineStations(Object.values(coline), branches),\n        [JSON.stringify(coline), deps]\n    );\n    const colors = stnIds.reduce(\n        (acc, stnId) => ({\n            ...acc,\n            [stnId]: colines\n                .filter(coline => coline.linePath.includes(stnId))\n                .map(coline => coline.colors)\n                .flat()\n                // TODO-coline: support multiple colines\n                .at(0) ?? [...theme, ...line_name],\n        }),\n        {} as { [stnId: string]: InterchangeInfo }\n    );\n\n    return (\n        <g id=\"stations_in_coline\">\n            {stnIds.map(stnId => (\n                <g key={stnId} transform={`translate(${xs[stnId]},${ys[stnId]})`}>\n                    <StationSHMetro stnId={stnId} stnState={stnStates[stnId]} color={colors[stnId][2]} />\n                </g>\n            ))}\n        </g>\n    );\n};\n","import React from 'react';\nimport { adjacencyList, criticalPathMethod, drawLine, getStnState, getXShareMTR } from '../methods/share';\nimport StationSHMetro from './station/station-shmetro';\nimport ColineSHMetro from './coline/coline-shmetro';\nimport { AtLeastOneOfPartial, Services, StationDict } from '../../../constants/constants';\nimport { useRootSelector } from '../../../redux';\n\ninterface servicesPath {\n    main: string[];\n    pass: string[];\n    service: Services;\n}\n\ntype Paths = AtLeastOneOfPartial<Record<Services, servicesPath>>;\n\nconst MainSHMetro = () => {\n    const { routes, branches, depsStr: deps } = useRootSelector(store => store.helper);\n    const param = useRootSelector(store => store.param);\n    const { svg_height, stn_list, branchSpacingPct, coline, direction } = useRootSelector(store => store.param);\n\n    const adjMat = adjacencyList(\n        param.stn_list,\n        () => 0,\n        () => 0\n    );\n\n    const criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    const realCP = criticalPathMethod(criticalPath.nodes[1], criticalPath.nodes.slice(-2)[0], adjMat);\n\n    const xShares = React.useMemo(\n        () => {\n            console.log('computing x shares');\n            return Object.keys(param.stn_list).reduce(\n                (acc, cur) => ({ ...acc, [cur]: getXShareMTR(cur, adjMat, branches) }),\n                {} as { [stnId: string]: number }\n            );\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [branches.toString(), JSON.stringify(adjMat)]\n    );\n    const lineXs: [number, number] = [\n        (param.svgWidth.railmap * param.padding) / 100,\n        param.svgWidth.railmap * (1 - param.padding / 100),\n    ];\n    const xs = Object.keys(xShares).reduce(\n        (acc, cur) => ({ ...acc, [cur]: lineXs[0] + (xShares[cur] / realCP.len) * (lineXs[1] - lineXs[0]) }),\n        {} as typeof xShares\n    );\n\n    // const yShares = React.useMemo(\n    //     () => {\n    //         console.log('computing y shares');\n    //         return Object.keys(param.stn_list).reduce(\n    //             (acc, cur) => ({ ...acc, [cur]: branches[0].includes(cur) ? 0 : 3 }),\n    //             {} as { [stnId: string]: number }\n    //         );\n    //     },\n    //     // eslint-disable-next-line react-hooks/exhaustive-deps\n    //     [deps]\n    // );\n    const yShares = React.useMemo(\n        () => {\n            console.log('computing y shares');\n            return Object.keys(stn_list).reduce((acc, cur) => {\n                if (branches[0].includes(cur)) {\n                    return { ...acc, [cur]: 0 };\n                } else {\n                    const branchOfStn = branches.slice(1).filter(branch => branch.includes(cur))[0];\n                    return { ...acc, [cur]: stn_list[branchOfStn[0]].children.indexOf(branchOfStn[1]) ? -3 : 3 };\n                }\n            }, {} as { [stnId: string]: number });\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps]\n    );\n\n    // filter out all negative yShares to draw the traditional railmap w/o coline and its branches\n    const lineYShares = Object.entries(yShares)\n        .filter(([k, v]) => v >= 0)\n        .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {} as typeof yShares);\n    const lineYs = Object.keys(lineYShares).reduce(\n        (acc, cur) => ({ ...acc, [cur]: (-lineYShares[cur] * branchSpacingPct * svg_height) / 300 }),\n        {} as typeof yShares\n    );\n\n    const stnStates = React.useMemo(\n        () => getStnState(param.current_stn_idx, routes, param.direction),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [param.current_stn_idx, param.direction, routes.toString()]\n    );\n\n    const servicesAll = Object.values(Services);\n    const servicesPresent = Object.values(param.stn_list)\n        .map(stationInfo => stationInfo.services)\n        .flat() // all services in all stations\n        .reduce(\n            (acc, cur) => {\n                acc[servicesAll.indexOf(cur)] = true;\n                return acc;\n            },\n            [false, false, false] as [boolean, boolean, boolean]\n        ) // set the flag in order\n        .map((bool, i) => [servicesAll[i], bool] as [Services, boolean]) // zip\n        .filter(s => s[1]) // get the existing service\n        .map(s => s[0]); // maintain the services' order\n\n    const linePaths = branches\n        .map(branch => drawLine(branch, stnStates))\n        .reduce(\n            (acc, cur) => {\n                acc.main.push(cur.main);\n                acc.pass.push(cur.pass);\n                return acc;\n            },\n            { main: [], pass: [] } as { main: string[][]; pass: string[][] }\n        );\n\n    const paths = servicesPresent.reduce(\n        (acc, service) => ({\n            ...acc,\n            [service]: (Object.keys(linePaths) as (keyof ReturnType<typeof drawLine>)[]).reduce(\n                (acc, cur) => ({\n                    ...acc,\n                    [cur]: linePaths[cur]\n                        .map(stns =>\n                            _linePath(\n                                stns,\n                                cur,\n                                xs,\n                                lineYs,\n                                direction,\n                                service,\n                                servicesPresent.length,\n                                stn_list\n                                // info_panel_type === 'sh2020' ? 'rightangle' : 'diagonal'\n                            )\n                        )\n                        .filter(path => path !== ''),\n                }),\n                {} as servicesPath\n            ),\n        }),\n        {} as Paths\n    );\n\n    return (\n        <g\n            id=\"main\"\n            transform={`translate(0,${param.svg_height * (Object.keys(coline).length > 0 ? 0.5 : 0.7 + 0.1)})`}\n        >\n            <Line paths={paths} direction={param.direction} />\n            <StationGroup\n                stnIds={Object.keys(lineYShares)\n                    .filter(stnId => !['linestart', 'lineend'].includes(stnId))\n                    .filter(stnId => stn_list[stnId].services.length !== 0)}\n                xs={xs}\n                ys={lineYs}\n                stnStates={stnStates}\n            />\n            {Object.keys(coline).length > 0 && (\n                <ColineSHMetro xs={xs} servicesPresent={servicesPresent} stnStates={stnStates} />\n            )}\n            {servicesPresent.length > 1 && <ServicesElements servicesLevel={servicesPresent} lineXs={lineXs} />}\n        </g>\n    );\n};\n\nexport default MainSHMetro;\n\nconst Line = (props: { paths: Paths; direction: 'l' | 'r' }) => {\n    const { theme } = useRootSelector(store => store.param);\n    const { paths, direction } = props;\n\n    return (\n        <>\n            {(Object.keys(paths) as Services[]).map((service, i) => (\n                <g\n                    key={`servicePath${i}`}\n                    transform={`translate(0,${i * 25})`}\n                    // the following line is a special case for pujiang line\n                    // where its pass line color should be white with outline\n                    // surrounding it, see #161 for details.\n                    filter={theme[2] === '#999999' ? 'url(#pujiang_outline_railmap)' : undefined}\n                >\n                    <g>\n                        {paths[service]?.pass.map((path, j) => (\n                            <path\n                                key={j}\n                                stroke=\"var(--rmg-grey)\"\n                                strokeWidth={12}\n                                fill=\"none\"\n                                d={path}\n                                markerStart={props.direction === 'l' ? 'url(#arrow_gray)' : undefined}\n                                markerEnd={props.direction === 'r' ? 'url(#arrow_gray)' : undefined}\n                                strokeLinejoin=\"round\"\n                            />\n                        ))}\n                    </g>\n                    <g>\n                        {paths[service]?.main.map((path, j) => (\n                            <path\n                                key={j}\n                                stroke=\"var(--rmg-theme-colour)\"\n                                strokeWidth={12}\n                                fill=\"none\"\n                                d={path}\n                                markerStart={direction === 'l' ? 'url(#arrow_theme_left)' : undefined}\n                                markerEnd={direction === 'r' ? 'url(#arrow_theme_right)' : undefined}\n                                strokeLinejoin=\"round\"\n                                filter={service === Services.local ? undefined : `url(#contrast-${service})`}\n                            />\n                        ))}\n                    </g>\n                </g>\n            ))}\n        </>\n    );\n};\n\nexport const _linePath = (\n    stnIds: string[],\n    type: 'main' | 'pass',\n    xs: { [stnId: string]: number },\n    ys: { [stnId: string]: number },\n    direction: 'l' | 'r',\n    services: Services,\n    servicesMax: number,\n    stn_list: StationDict, // only used to determine startFromTerminal or endAtTerminal\n    bend: 'rightangle' | 'diagonal' = 'rightangle'\n) => {\n    var [prevY, prevX] = [] as number[];\n    var path: { [key: string]: number[] } = {};\n\n    const servicesDelta = {\n        local: 0,\n        express: 20,\n        direct: 40,\n    }[services]; // TODO: enum Services could be a better idea?\n    const servicesPassDelta = servicesMax > 1 ? 50 : 0;\n\n    // extra short line on either end\n    let e1 = 30;\n    // check if path starts from or ends at the terminal\n    // and change e1 to 0 if it matches\n    if (stnIds.length > 0) {\n        let startFromTerminal = false,\n            endAtTerminal = false;\n        if (stn_list[stnIds.at(-1) || 0].children.some(stnId => ['linestart', 'lineend'].includes(stnId))) {\n            endAtTerminal = true;\n        } else if (stn_list[stnIds.at(0) || 0].parents.some(stnId => ['linestart', 'lineend'].includes(stnId))) {\n            startFromTerminal = true;\n        }\n        e1 = startFromTerminal || endAtTerminal ? e1 : 0;\n    }\n\n    // diagonal use e2 to make soft line\n    const e2 = 30;\n\n    stnIds.forEach(stnId => {\n        var x = xs[stnId];\n        var y = ys[stnId];\n        if (!prevY && prevY !== 0) {\n            [prevX, prevY] = [x, y];\n            path['start'] = [x, y];\n            return;\n        }\n        if (y === 0) {\n            // merge back to main line\n            if (y !== prevY) {\n                path['bifurcate'] = [prevX, prevY];\n            }\n        } else {\n            // on the branch line\n            if (y !== prevY) {\n                path['bifurcate'] = [x, y];\n            }\n        }\n        path['end'] = [x, y];\n        [prevX, prevY] = [x, y];\n    });\n\n    // generate path\n    if (!path.hasOwnProperty('start')) {\n        // no line generated\n        // keys in path: none\n        return '';\n    } else if (!path.hasOwnProperty('end')) {\n        // little line (only beyond terminal station)\n        // keys in path: start\n        let [x, y] = path['start'];\n        if (type === 'main') {\n            // current at terminal(end) station, draw the litte main line\n            if (direction === 'l') {\n                return `M ${x - e1 - servicesDelta},${y} H ${x}`;\n            } else {\n                return `M ${x},${y} H ${x + e1 + servicesDelta}`;\n            }\n        } else {\n            // type === 'pass'\n            // current at terminal(start) station, draw the litte pass line\n            if (direction === 'l') {\n                return `M ${x},${y} L ${x + e1 + servicesPassDelta},${y}`;\n            } else {\n                return `M ${x - e1 - servicesPassDelta},${y} L ${x},${y}`;\n            }\n        }\n    } else if (!path.hasOwnProperty('bifurcate')) {\n        // general main line\n        // keys in path: start, end\n        let [x, y] = path['start'],\n            h = path['end'][0];\n        if (type === 'main') {\n            if (direction === 'l') {\n                return `M ${x - e1 - servicesDelta},${y} H ${h}`;\n            } else {\n                return `M ${x},${y} H ${h + e1 + servicesDelta}`;\n            }\n        } else {\n            // type === 'pass'\n            if (direction === 'l') {\n                return `M ${x - e1},${y} H ${h + e1 + servicesPassDelta}`;\n            } else {\n                return `M ${x - e1 - servicesPassDelta},${y} H ${h + e1}`;\n            }\n        }\n    } else {\n        // main line bifurcate here to become the branch line\n        // and path return here are only branch line\n        // keys in path: start, bifurcate, end\n        // TODO: make diagonal available to `sh`\n\n        let [x, y] = path['start'];\n        let xb = path['bifurcate'][0];\n        let [xm, ym] = path['end'];\n        if (type === 'main') {\n            if (direction === 'l') {\n                if (ym > y) {\n                    console.log(path);\n                    // main line, left direction, center to upper\n                    if (bend === 'rightangle') return `M ${x - e1},${y} H ${xm} V ${ym}`;\n                    // center to upper/rightangle, lower to center/diagonal\n                    else return `M ${x},${y} H ${x + e2} L ${xb - e2},${ym} H ${xm}`;\n                } else {\n                    // wrong marker\n                    // main line, left direction, upper to center\n                    if (bend === 'rightangle') return `M ${x},${y} V ${ym} H ${xm}`;\n                    // upper to center/rightangle, center to lower/diagonal\n                    else return `M ${x - e1},${y} H ${xb + e2} L ${xm - e2},${ym} H ${xm}`;\n                }\n            } else {\n                if (ym > y) {\n                    // wrong marker\n                    // main line, right direction, upper to center\n                    if (bend === 'rightangle') return `M ${x},${y} H ${xm} V ${ym}`;\n                    // upper to center/rightangle, center to lower/diagonal\n                    else return `M ${x},${y} H ${x + e2} L ${xb - e2},${ym} H ${xm + e1}`;\n                } else {\n                    // main line, right direction, center to upper\n                    if (bend === 'rightangle') return `M ${x},${y} V ${ym} H ${xm + e1}`;\n                    // center to upper/rightangle, lower to center/diagonal\n                    else return `M ${x},${y} H ${xb + e2} L ${xm - e2},${ym} H ${xm}`;\n                }\n            }\n        } else {\n            // type === 'pass'\n            if (direction === 'l') {\n                if (ym > y) {\n                    // pass line, left direction, center to upper\n                    if (bend === 'rightangle') return `M ${x - e1},${y} H ${xm} V ${ym}`;\n                    // center to upper/rightangle, lower to center/diagonal\n                    else return `M ${x},${y} H ${x + e2} L ${xb - e2},${ym} H ${xm + e1}`;\n                } else {\n                    // pass line, left direction, upper to center\n                    if (bend === 'rightangle') return `M ${x},${y} V ${ym} H ${xm + e1}`;\n                    // upper to center/rightangle, center to lower/diagonal\n                    else return `M ${x - e1},${y} H ${xb + e2} L ${xm - e2},${ym} H ${xm}`;\n                }\n            } else {\n                if (ym > y) {\n                    // pass line, right direction, upper to center\n                    if (bend === 'rightangle') return `M ${x - e1},${y} H ${xm} V ${ym}`;\n                    // upper to center/rightangle, center to lower/diagonal\n                    return `M ${x},${y} H ${x + e2} L ${xb - e2},${ym} H ${xm + e1}`;\n                } else {\n                    // pass line, right direction, center to upper\n                    if (bend === 'rightangle') return `M ${x},${y} V ${ym} H ${xm + e1}`;\n                    // center to upper/rightangle, lower to center/diagonal\n                    return `M ${x - e1},${y} H ${xb + e2} L ${xm - e2},${ym} H ${xm}`;\n                }\n            }\n        }\n    }\n};\n\nexport interface StationGroupProps {\n    stnIds: string[];\n    xs: { [stnId: string]: number };\n    ys: { [stnId: string]: number };\n    stnStates: { [stnId: string]: -1 | 0 | 1 };\n}\n\nconst StationGroup = (props: StationGroupProps) => {\n    const { xs, ys, stnStates, stnIds } = props;\n\n    return (\n        <g>\n            {stnIds.map(stnId => (\n                <g key={stnId} transform={`translate(${xs[stnId]},${ys[stnId]})`}>\n                    <StationSHMetro stnId={stnId} stnState={stnStates[stnId]} />\n                </g>\n            ))}\n        </g>\n    );\n};\n\nconst ServicesElements = (props: { servicesLevel: Services[]; lineXs: number[] }) => {\n    const { svg_height, direction, svgWidth } = useRootSelector(store => store.param);\n    const dy = -svg_height + 130;\n\n    const servicesLevel = props.servicesLevel.map(\n        service =>\n            ({\n                local: '普通车',\n                express: '大站车',\n                direct: '直达车',\n            }[service])\n    );\n\n    // let dx = props.direction === 'r' ? 5 : param.svgWidth.railmap - 55;\n    const labelX = direction === 'r' ? props.lineXs[0] - 42 : props.lineXs[1] + 42;\n\n    let dx_hint = props.servicesLevel.length === 2 ? 350 : 500;\n\n    return React.useMemo(\n        () => (\n            <g>\n                {servicesLevel.map((service, i) => (\n                    <g key={service} transform={`translate(${labelX},${i * 25})`}>\n                        <rect x={-27.5} height={10} width={55} fill={'white'} stroke={'black'} y={-5}></rect>\n                        <text\n                            className=\"rmg-name__zh\"\n                            fontSize={9}\n                            y={3}\n                            textAnchor=\"middle\"\n                        >{`${service}运行线`}</text>\n                    </g>\n                ))}\n                <g transform={`translate(${direction === 'r' ? 30 : svgWidth.railmap - dx_hint},${dy})`}>\n                    <text className=\"rmg-name__zh\">图例：</text>\n                    {servicesLevel.map((serviceLevel, i) => (\n                        <g key={`serviceLevel${i}`} transform={`translate(${i * 150 + 50},0)`}>\n                            <line\n                                x1=\"0\"\n                                x2=\"35\"\n                                y1=\"-5\"\n                                y2=\"-5\"\n                                stroke=\"var(--rmg-theme-colour)\"\n                                strokeWidth=\"12\"\n                                filter={i === 2 ? 'url(#contrast-direct)' : i === 1 ? 'url(#contrast-express)' : ''}\n                            />\n                            <use x=\"17.5\" y=\"-5\" xlinkHref=\"#stn_sh\" fill=\"var(--rmg-theme-colour)\" />\n                            <text x=\"40\" className=\"rmg-name__zh\">{`${serviceLevel}停靠站`}</text>\n                        </g>\n                    ))}\n                </g>\n            </g>\n        ),\n        [svg_height, direction, svgWidth, props.servicesLevel, props.lineXs]\n    );\n};\n\nexport const DirectionElements = () => {\n    const { direction, svgWidth, coline } = useRootSelector(store => store.param);\n    // arrow will be black stroke with white fill in coline\n    const isColine = Object.keys(coline).length ? true : false;\n\n    return React.useMemo(\n        () => (\n            <g transform={`translate(${direction === 'l' ? 50 : svgWidth.railmap - 150},50)`}>\n                <text className=\"rmg-name__zh\">列车前进方向</text>\n                <path\n                    d=\"M60,60L0,0L60-60H100L55-15H160V15H55L100,60z\"\n                    stroke={!isColine ? undefined : 'var(--rmg-black)'}\n                    strokeWidth={!isColine ? undefined : 5}\n                    fill={!isColine ? 'var(--rmg-theme-colour)' : 'var(--rmg-white)'}\n                    transform={`translate(${direction === 'l' ? -30 : 125},-5)rotate(${\n                        direction === 'l' ? 0 : 180\n                    })scale(0.15)`}\n                />\n            </g>\n        ),\n        [direction, coline, svgWidth.railmap]\n    );\n};\n","import { ColineInfo, InterchangeInfo } from '../../../constants/constants';\nimport { drawLine } from './share';\n\nexport interface ColineLinePath {\n    main: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n}\n\n/**\n * Return all stations from ColineInfo's `from` and `to` with coline color preserved.\n */\nexport const calculateColineStations = (colineInfoList: ColineInfo[], branches: string[][]) =>\n    colineInfoList\n        .map(coLine => {\n            const involvedBranches = branches.filter(\n                branch => branch.includes(coLine.from) && branch.includes(coLine.to)\n            );\n\n            // the current coLineInfo fall on two separate branches,\n            // which should not be possible in current design.\n            if (involvedBranches.length !== 1) return { linePath: [], colors: coLine.colors };\n\n            const branch = involvedBranches.flat();\n            const a = branch.indexOf(coLine.from);\n            const b = branch.indexOf(coLine.to);\n            const linePath = a < b ? branch.slice(a, b + 1) : branch.slice(b, a + 1);\n            return {\n                linePath: linePath,\n                colors: coLine.colors,\n            };\n        })\n        .filter(branchWithColine => branchWithColine.linePath.length !== 0);\n\n/**\n * Return coline segments with stations in main/pass order.\n */\nexport const calculateColine = (\n    branchWithColine: ReturnType<typeof calculateColineStations>,\n    stnStates: {\n        [stnId: string]: 0 | 1 | -1;\n    }\n) =>\n    branchWithColine\n        .map(branchWithColine => {\n            const linePaths = drawLine(branchWithColine.linePath, stnStates);\n            return {\n                main: [\n                    {\n                        linePath: linePaths.main,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n                pass: [\n                    {\n                        linePath: linePaths.pass,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n            };\n        })\n        // .map(branchWithColine =>\n        //     (\n        //         Object.entries(drawLine(branchWithColine.linePath, stnStates)) as [\n        //             keyof ReturnType<typeof drawLine>,\n        //             string[]\n        //         ][]\n        //     )\n        //         .map(([type, linePath]) => ({ [type]: { linePath: linePath, colors: branchWithColine.colors } }))\n        //         .reduce((acc, cur) => ({ ...acc, ...cur }), { main: [], pass: [] } as ColineLinePath)\n        // )\n        .reduce(\n            (acc, cur) => {\n                acc.main = [...acc.main, ...cur.main];\n                acc.pass = [...acc.pass, ...cur.pass];\n                return acc;\n            },\n            { main: [], pass: [] } as ColineLinePath\n        );\n"],"names":["defaultTheme","ColineSHMetro","props","xs","servicesPresent","stnStates","useRootSelector","store","param","svg_height","direction","stn_list","current_stn_idx","branchSpacingPct","info_panel_type","colineInfo","coline","helper","branches","deps","depsStr","yShares","React","console","log","Object","keys","reduce","acc","cur","includes","branchOfStn","slice","filter","branch","children","indexOf","colineYShares","entries","k","v","colineYs","colineStns","calculateColine","calculateColineStations","values","co","display","JSON","stringify","colinePaths","service","map","colineStn","path","_linePath","linePath","length","colors","colineStations","flat","COLINE_GAP","id","transform","CoLine","paths","ColineStationInMainLine","ys","lineWidth","colineGap","ColineStationGroup","stnIds","stnId","services","i","pass","colinePath","j","stroke","strokeWidth","fill","d","strokeLinejoin","Services","undefined","main","y1","y2","x1","x2","gradientUnits","color","offset","stopColor","c","join","refY","refX","at","markerStart","markerEnd","LINE_WIDTH","line_name","theme","stns","curStn","x","y","find","concat","stn","colineStation","height","dy","width","xlinkHref","colines","stnState","routes","adjMat","adjacencyList","criticalPath","criticalPathMethod","realCP","nodes","xShares","getXShareMTR","toString","lineXs","svgWidth","railmap","padding","len","lineYShares","lineYs","getStnState","servicesAll","stationInfo","bool","s","linePaths","drawLine","push","Line","StationGroup","ServicesElements","servicesLevel","type","servicesMax","bend","prevY","prevX","servicesDelta","local","express","direct","servicesPassDelta","e1","startFromTerminal","endAtTerminal","some","parents","e2","forEach","hasOwnProperty","xb","xm","ym","h","labelX","dx_hint","className","fontSize","textAnchor","serviceLevel","DirectionElements","isColine","colineInfoList","coLine","involvedBranches","from","to","a","b","branchWithColine"],"sourceRoot":""}