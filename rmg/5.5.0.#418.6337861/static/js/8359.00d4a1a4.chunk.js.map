{"version":3,"file":"static/js/8359.00d4a1a4.chunk.js","mappings":"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","sources":["svgs/mtr/line-diagram-utils.ts","svgs/railmap/methods/mtr.ts","svgs/railmap/methods/share.ts","../javascript/esm|/home/runner/work/rmg/rmg/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["import { StationDict } from '../../constants/constants';\n\n/**\n * @return - negative: above main line, positive: below main line\n */\nexport const getStationYShare = (stationId: string, branches: string[][], stationList: StationDict): number => {\n    const mainBranch = branches[0];\n\n    if (mainBranch.includes(stationId)) {\n        // on main branch\n        if (branches.slice(1).find(branch => branch.includes(stationId))) {\n            // node shared by multiple branches\n            return 0;\n        } else {\n            const openJawSiblingBranch = branches.slice(1).find(branch => {\n                const isLeftOpenJaw = branch[0] === 'linestart';\n                const hasSiblingBranchOpenJawOnTheLeft =\n                    mainBranch.indexOf(stationId) < mainBranch.indexOf(branch.slice(-1)[0]);\n\n                const isRightOpenJaw = branch.slice(-1)[0] === 'lineend';\n                const hasSiblingBranchOpenJawOnTheRight = mainBranch.indexOf(stationId) > mainBranch.indexOf(branch[0]);\n\n                return (\n                    (isLeftOpenJaw && hasSiblingBranchOpenJawOnTheLeft) ||\n                    (isRightOpenJaw && hasSiblingBranchOpenJawOnTheRight)\n                );\n            });\n\n            if (openJawSiblingBranch) {\n                // on main branch but open jaw\n                // NOTE: determine y share of node by children ordering, not by whether it's a branch or not (like GZMTR)\n                // TODO: Remove requirement on stationList arg\n                return stationList[openJawSiblingBranch[0]].children.indexOf(openJawSiblingBranch[1]) === 1 ? -1 : 1;\n            } else {\n                // pure main branch without siblings or main branch with sidings\n                return 0;\n            }\n        }\n    } else {\n        // on branch/sidings\n        const branchBelongsTo = branches.slice(1).find(branch => branch.includes(stationId));\n        if (branchBelongsTo) {\n            const isSiding = branchBelongsTo[0] !== 'linestart' && branchBelongsTo.slice(-1)[0] !== 'lineend';\n            if (isSiding) {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1.2 : -1.2;\n            } else {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1 : -1;\n            }\n        } else {\n            // fallback\n            return 0;\n        }\n    }\n};\n\nexport const getSidingPath = (coords: [number, number][]): string => {\n    const TURNING_RADIUS = 6;\n    const RIGHT_DOWN_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const DOWN_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const RIGHT_UP_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n    const UP_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n\n    let prevCoord: [number, number] | undefined;\n    let paths: string[] = [];\n\n    for (let coord of coords) {\n        if (!prevCoord) {\n            paths.push('M' + coord.join(','));\n        } else {\n            if (coord[1] === prevCoord[1]) {\n                // horizontal\n                paths.push('H' + coord[0]);\n            } else {\n                const midPointX = (coord[0] + prevCoord[0]) / 2 - (prevCoord[1] === 0 ? 0 : TURNING_RADIUS * 2);\n                paths.push('H' + midPointX);\n\n                if (coord[1] > prevCoord[1]) {\n                    // turn to below\n                    paths.push(RIGHT_DOWN_ARC);\n                    paths.push('V' + (coord[1] - TURNING_RADIUS));\n                    paths.push(DOWN_RIGHT_ARC);\n                } else {\n                    // turn to above\n                    paths.push(RIGHT_UP_ARC);\n                    paths.push('V' + (coord[1] + TURNING_RADIUS));\n                    paths.push(UP_RIGHT_ARC);\n                }\n\n                paths.push('H' + coord[0]);\n            }\n        }\n        // update prev coordinate\n        prevCoord = coord;\n    }\n\n    return paths.join(' ').replace(/( H([\\d.]+))+/g, ' H$2');\n};\n","import { Stations } from './share';\nimport { StationDict, StationInfo } from '../../../constants/constants';\nimport { getSidingPath } from '../../mtr/line-diagram-utils';\n\nexport const leftWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'l') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.8;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.8;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        // osi22 not end\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'l' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].parents.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].parents[0]].children.length === 2) res += 0.4;\n    return res;\n};\n\nexport const rightWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'r') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.8;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.8;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'r' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].children.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].children[0]].parents.length === 2) res += 0.4;\n    return res;\n};\n\nexport class StationsMTR extends Stations {\n    protected leftWideFactor = (stnId: string) => {\n        return leftWideFactor(this.stnList, stnId);\n    };\n\n    protected rightWideFactor = (stnId: string) => {\n        return rightWideFactor(this.stnList, stnId);\n    };\n\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            const isSiding = branch[0] !== 'linestart' && branch.slice(-1)[0] !== 'lineend';\n\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            if (isSiding) {\n                linePaths.sidingMain.push(getSidingPath(lineMainStns.map(id => [xs[id], ys[id]])));\n                linePaths.sidingPass.push(getSidingPath(linePassStns.map(id => [xs[id], ys[id]])));\n            } else {\n                linePaths.main.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        lineMainStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n                linePaths.pass.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        linePassStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n            }\n        });\n\n        return linePaths;\n    }\n}\n\nexport class StationsSHMetro extends StationsMTR {\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            linePaths.main.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    lineMainStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n            linePaths.pass.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    linePassStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n        });\n\n        return linePaths;\n    }\n}\n","import { ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["getStationYShare","stationId","branches","stationList","mainBranch","includes","slice","find","branch","openJawSiblingBranch","isLeftOpenJaw","hasSiblingBranchOpenJawOnTheLeft","indexOf","isRightOpenJaw","hasSiblingBranchOpenJawOnTheRight","children","branchBelongsTo","getSidingPath","coords","prevCoord","RIGHT_DOWN_ARC","DOWN_RIGHT_ARC","RIGHT_UP_ARC","UP_RIGHT_ARC","paths","coord","push","midPointX","TURNING_RADIUS","join","replace","leftWideFactor","stnList","stnId","res","transfer","ls","info","map","val","length","tick_direc","parents","rightWideFactor","StationsMTR","stnStates","lineXs","xs","ys","branchSpacing","cp","e","linePaths","main","pass","sidingMain","sidingPass","forEach","i","isSiding","lineMainStns","filter","linePassStns","unshift","id","criticalPath","_linePath","Stations","StationsSHMetro","adjacencyList","leftW","rightW","Object","keys","reduce","acc","cur","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","child","maxLength","Math","max","getXShareMTR","branchOfStn","partSource","partSink","leftOpenJaw","lens","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","data","yShares","xShares","namePoss","pathTurnParams","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","stnPred","getYShare","stnIds","realXs","realYs","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","stations","drawLine","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","F","s","n","done","value","_e","f","TypeError","err","normalCompletion","didErr","call","step","next","_e2"],"sourceRoot":""}