{"version":3,"file":"static/js/4074.e82f2708.chunk.js","mappings":"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","sources":["svgs/destination/destination-shmetro.tsx","svgs/railmap/methods/shmetro-loop.ts","svgs/svg-wrapper.tsx"],"sourcesContent":["import React, { forwardRef, memo, useEffect, useMemo, useRef, useState } from 'react';\nimport { useRootSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { CanvasType, ColineInfo, ColourHex, MonoColour, Name, ShortDirection } from '../../constants/constants';\nimport { get_pivot_stations } from '../railmap/methods/shmetro-loop';\nimport SvgWrapper from '../svg-wrapper';\n\nconst CANVAS_TYPE = CanvasType.Destination;\n\nexport default function DestinationSHMetro() {\n    const { canvasScale } = useRootSelector(state => state.app);\n    const { svgWidth: svgWidths, svg_height: svgHeight, theme } = useRootSelector(store => store.param);\n\n    const svgWidth = svgWidths[CANVAS_TYPE];\n\n    return (\n        <SvgWrapper\n            type={CANVAS_TYPE}\n            svgWidth={svgWidth}\n            svgHeight={svgHeight}\n            canvasScale={canvasScale}\n            theme={theme}\n        >\n            <DefsSHMetro />\n            <DestSHMetro />\n        </SvgWrapper>\n    );\n}\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n    </defs>\n));\n\nconst DestSHMetro = () => {\n    const { routes, branches } = useRootSelector(store => store.helper);\n    const {\n        line_name,\n        theme,\n        current_stn_idx: current_stn_id,\n        direction,\n        stn_list,\n        info_panel_type,\n        loop,\n        coline,\n    } = useRootSelector(store => store.param);\n\n    // get valid destination of each branch\n    const get_valid_destinations = (routes: string[][], direction: ShortDirection, current_stn_id: string) => [\n        ...new Set(\n            routes\n                .filter(route => route.includes(current_stn_id))\n                .map(route => {\n                    const res = route.filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n                    return direction === 'l' ? res[0] : res.reverse()[0];\n                })\n        ),\n    ];\n    // get the name from the destination id(s)\n    const get_dest_names = (dest_ids: string[], one_line: boolean) =>\n        !one_line\n            ? dest_ids.map(id => stn_list[id].name.map(s => s.replace('\\\\', '')) as Name)\n            : [\n                  // only one line in `sh` type\n                  [\n                      dest_ids.map(id => stn_list[id].name[0]).join('，'),\n                      dest_ids.map(id => stn_list[id].name[1]).join(', '),\n                  ].map(s => s.replace('\\\\', '')) as Name,\n              ];\n\n    // get destination id(s)\n    const valid_dest_ids = !loop\n        ? get_valid_destinations(routes, direction, current_stn_id)\n        : get_pivot_stations(branches, direction, stn_list, current_stn_id);\n    // get coline destination id(s)\n    // note that for loop, coline branches' destination id(s) are needed\n    const coline_dest_ids = (!loop ? valid_dest_ids : get_valid_destinations(routes, direction, current_stn_id)).filter(\n        valid_dest_id =>\n            branches\n                .slice(1)\n                .filter(branch => isColineBranch(branch, stn_list))\n                .some(branch => branch.includes(valid_dest_id))\n    );\n    // filter out coline destination id(s)\n    const regular_dest_ids = valid_dest_ids.filter(valid_dest_id => !coline_dest_ids.includes(valid_dest_id));\n\n    // destination names of loop line, `sh2020` type will always be two lines\n    const dest_names = get_dest_names(regular_dest_ids, !loop && !(info_panel_type === 'sh2020'));\n    console.log(dest_names);\n    const coline_dest_names = get_dest_names(coline_dest_ids, true);\n\n    // this will give the space for at most two lines of dest_names\n    const coline_dy = 250;\n    // get coline info from coline_dest_ids\n    const colines = Object.fromEntries(\n        coline_dest_ids\n            .map(coline_dest_id => [\n                coline_dest_id,\n                Object.values(coline)\n                    .filter(co => co.from === coline_dest_id || co.to === coline_dest_id)\n                    .at(0),\n            ])\n            .filter(([key, val]) => val)\n    ) as {\n        [k: string]: ColineInfo;\n    };\n    return (\n        <>\n            <Dest\n                dest_names={dest_names}\n                line_name={line_name}\n                line_color={[theme[2], theme[3]]}\n                coline={coline_dest_ids.length ? true : false}\n                upper={coline_dest_ids.length ? true : false}\n            />\n            {coline_dest_ids.length &&\n                // multiple coline dest is not supported yet\n                coline_dest_ids.map(coline_dest_id => (\n                    <g key={`coline_${coline_dest_id}`} transform={`translate(0,${-coline_dy})`}>\n                        <Dest\n                            dest_names={[coline_dest_names.at(0)!]}\n                            line_name={colines[coline_dest_id]?.colors.at(0)!.slice(4) as Name}\n                            line_color={[\n                                colines[coline_dest_id]?.colors.at(0)![2],\n                                colines[coline_dest_id]?.colors.at(0)![3],\n                            ]}\n                            coline\n                            upper={false}\n                        />\n                    </g>\n                ))}\n        </>\n    );\n};\n\nconst Dest = (props: {\n    dest_names: Name[];\n    line_name: Name;\n    line_color: [ColourHex, MonoColour]; // override coline color\n    coline: boolean; // hide the marker if it is a coline\n    upper: boolean; // coline needs the line in the upper position\n}) => {\n    const { dest_names, line_name, line_color, coline, upper } = props;\n    const {\n        current_stn_idx: current_stn_id,\n        direction,\n        platform_num,\n        svgWidth,\n        svg_height,\n    } = useRootSelector(store => store.param);\n\n    const terminalEl = useRef<SVGGElement | null>(null);\n    const [terminalBBox, setTerminalBBox] = useState({ width: 0 } as SVGRect);\n    useEffect(\n        () => setTerminalBBox(terminalEl.current!.getBBox()),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [JSON.stringify(dest_names), JSON.stringify(current_stn_id)]\n    );\n\n    const [middle, MARGIN, PADDING, LINEBOX_WIDTH, PLATFORM_WIDTH] = [svgWidth.destination / 2, 10, 36, 264, 325];\n    // Alignment Priority:\n    // 1. Centre of canvas\n    // 2. Centre of remaining\n    const platformX =\n        middle - MARGIN - PADDING - terminalBBox.width >= PLATFORM_WIDTH / 2 &&\n        middle - MARGIN - PADDING - LINEBOX_WIDTH >= PLATFORM_WIDTH / 2\n            ? middle\n            : direction === 'l'\n            ? (svgWidth.destination + terminalBBox.width - LINEBOX_WIDTH) / 2\n            : (svgWidth.destination - terminalBBox.width + LINEBOX_WIDTH) / 2;\n\n    // the platform screen doors flash light\n    // #20\n    // $('g#station_info_shmetro > rect').attr({ transform: `translate(${this._svgDestWidth / 2},${250 + dh})` })\n\n    return (\n        <g transform={`translate(0,${svg_height - 300})`}>\n            <path\n                stroke={line_color[0]}\n                strokeWidth={12}\n                d={\n                    direction === 'l'\n                        ? `M${svgWidth.destination - 24},16 H 36`\n                        : `M24,16 H ${svgWidth.destination - 36}`\n                }\n                transform={`translate(0,${!upper ? 220 : -20})`}\n                markerEnd={!coline ? 'url(#slope)' : undefined}\n            />\n\n            <Terminal ref={terminalEl} dest_names={dest_names} />\n            {platform_num !== '' && (\n                <g transform={`translate(${platformX},0)`}>\n                    <PlatformNum />\n                </g>\n            )}\n\n            {line_name[0].match(/^[\\w\\d]+/) ? (\n                <LineNameBoxNumber line_name={line_name} line_color={line_color} />\n            ) : (\n                <LineNameBoxText line_name={line_name} line_color={line_color} />\n            )}\n        </g>\n    );\n};\n\nconst Terminal = forwardRef((props: { dest_names: Name[] }, ref: React.Ref<SVGGElement>) => {\n    const { dest_names } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    return (\n        <g ref={ref} transform={`translate(${direction === 'l' ? 36 : svgWidth.destination - 36},145)`}>\n            {/* this is not a generalized implementation, only dest length of 1 and 2 are supported */}\n            <g transform={`translate(0,${dest_names.length === 2 ? -20 : 20})`}>\n                <path\n                    d=\"M60,60L0,0L60-60H100L55-15H160V15H55L100,60z\"\n                    fill=\"black\"\n                    transform={`rotate(${direction === 'l' ? 0 : 180})scale(0.8)`}\n                />\n            </g>\n            <g\n                textAnchor={direction === 'l' ? 'start' : 'end'}\n                transform={`translate(${direction === 'l' ? 128 + 20 : -128 - 20},25)`}\n            >\n                {dest_names.map((name, i) => (\n                    <React.Fragment key={i}>\n                        <text className=\"rmg-name__zh\" fontSize={70} dy={i * -100 + 7} key={`zh${i}`}>\n                            {'往' + name[0]}\n                        </text>\n                        <text className=\"rmg-name__en\" fontSize={25} dy={i * -100 + 40} key={`en${i}`}>\n                            {'To ' + name[1]}\n                        </text>\n                    </React.Fragment>\n                ))}\n            </g>\n        </g>\n    );\n});\n\nconst PlatformNum = () => {\n    const { platform_num } = useRootSelector(store => store.param);\n\n    // Total width: 325\n    return useMemo(\n        () => (\n            <g transform={`translate(${-325 / 2 + 60},150)`}>\n                <circle r={60} fill=\"none\" stroke=\"black\" strokeWidth={2} />\n                <text className=\"rmg-name__en\" dominantBaseline=\"central\" fontSize={120} textAnchor=\"middle\">\n                    {platform_num}\n                </text>\n                <text className=\"rmg-name__zh\" fontSize={100} dominantBaseline=\"central\" x={65}>\n                    站台\n                </text>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [platform_num]\n    );\n};\n\nconst LineNameBoxText = (props: { line_name: Name; line_color: [ColourHex, MonoColour] }) => {\n    const { line_name, line_color } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    const boxX = direction === 'l' ? svgWidth.destination - 42 : 42;\n\n    // get the exact station name width so that the\n    // line color rectangle can be the right width.\n    const stnNameEl = useRef<SVGGElement | null>(null);\n    // the original name position\n    const [bBox, setBBox] = React.useState({ width: 0 } as DOMRect);\n    React.useEffect(\n        () => setBBox(stnNameEl.current!.getBBox()),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [...line_name]\n    );\n\n    const rectDx = (direction === 'l' ? -bBox.width : 0) - 6;\n    const stnNameEnDx = ((direction === 'l' ? -1 : 1) * bBox.width) / 2;\n\n    return useMemo(\n        () => (\n            <g transform={`translate(${boxX},92)`}>\n                <rect fill={line_color[0]} x={rectDx} width={bBox.width + 10} height={120} />\n                <g textAnchor={direction === 'r' ? 'start' : 'end'} transform=\"translate(0,68)\" fill={line_color[1]}>\n                    <g ref={stnNameEl}>\n                        <text className=\"rmg-name__zh\" fontSize={68}>\n                            {line_name[0]}\n                        </text>\n                    </g>\n                    <text className=\"rmg-name__en\" fontSize={30} textAnchor=\"middle\" x={stnNameEnDx} dy={42}>\n                        {line_name[1]}\n                    </text>\n                </g>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [bBox, ...line_name, ...line_color, direction, svgWidth.destination]\n    );\n};\n\nconst LineNameBoxNumber = (props: { line_name: Name; line_color: [ColourHex, MonoColour] }) => {\n    const { line_name, line_color } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    const [lineNumber, lineNameRes] = line_name[0].match(/^[\\w\\d]+|.+/g) as string[];\n\n    // Number width: 108\n    // Text width: 136\n    // Gap: 20\n    // Left: 108/2 + 20 + 136 = 210\n    // Right: 108/2 = 54\n    const boxX = direction === 'l' ? svgWidth.destination - 36 - 210 : 36 + 54;\n\n    // Total width: 264\n    return useMemo(\n        () => (\n            <g transform={`translate(${boxX},92)`}>\n                <rect fill={line_color[0]} x={-54} width={108} height={120} />\n                <text\n                    className=\"rmg-name__zh\"\n                    fill={line_color[1]}\n                    fontSize={96}\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"central\"\n                    transform=\"translate(0,60)\"\n                    letterSpacing={-5}\n                >\n                    {lineNumber}\n                </text>\n                <g textAnchor=\"start\" transform=\"translate(74,68)\">\n                    <text className=\"rmg-name__zh\" fontSize={68}>\n                        {lineNameRes}\n                    </text>\n                    <text className=\"rmg-name__en\" fontSize={30} dy={42}>\n                        {line_name[1]}\n                    </text>\n                </g>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [boxX, ...line_name, ...line_color, direction, svgWidth.destination]\n    );\n};\n","import { ShortDirection, StationDict } from '../../../constants/constants';\n\n/**\n * Split the loopline into four sides according to left_and_right_factor and bottom_factor.\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param current_stn_id Current station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns = (\n    loopline: string[],\n    current_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const current_stn_idx = loopline.findIndex(val => val === current_stn_id);\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + current_stn_idx - Math.floor(top_factor / 2) + (top_factor % 2 === 0 ? 1 : 0);\n    const split_b = loopline.length + current_stn_idx + Math.floor(top_factor / 2);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with one branch into four sides according to left_and_right_factor and bottom_factor.\n * Note that the top side must start from the branch_stn_id.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_id Branch station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branch = (\n    loopline: string[],\n    branch_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + loopline.findIndex(val => val === branch_stn_id);\n    const another_branch_stn_id = non_undefined_loopline[split_a + top_factor - 1];\n    const split_b =\n        loopline.length +\n        loopline.findIndex(val => val === another_branch_stn_id) +\n        (split_a + top_factor > loopline.length * 2 ? loopline.length : 0);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with two branches into four sides according to left_and_right_factor and arc.\n * Note that the top side must start from one of the branch_stn_ids and end at another.\n * Also the top side will be the major or the minor arc between branch_stn_ids.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > the major or the minor arc length between branch_stn_ids +\n *                          left_and_right_factor * 2\n *     2. left_and_right_factor >= 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_ids Branches station id.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @param arc Which arc will be the top side, the major or the minor.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branches = (\n    loopline: string[],\n    branch_stn_ids: [string, string],\n    left_and_right_factor: number,\n    arc: 'major' | 'minor'\n) => {\n    let split_a = loopline.findIndex(val => val === branch_stn_ids[0]);\n    let split_b = loopline.findIndex(val => val === branch_stn_ids[1]);\n    // swap a and b if a is bigger than b\n    [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]] =\n        split_a > split_b\n            ? [split_b, split_a, branch_stn_ids[1], branch_stn_ids[0]]\n            : [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]];\n    const top_a = loopline.slice(split_a, split_b + 1);\n    const top_b = loopline.filter(stn => !top_a.filter(stn => !branch_stn_ids.includes(stn)).includes(stn));\n    // which arc we use on the top will result to different bottom factor\n    const bottom_factor =\n        loopline.length -\n        (arc === 'major' ? Math.max : Math.min)(top_a.length, top_b.length) -\n        left_and_right_factor * 2;\n    const branch_stn_id =\n        arc === 'major'\n            ? top_a.length > top_b.length\n                ? branch_stn_ids[0]\n                : branch_stn_ids[1]\n            : top_a.length > top_b.length\n            ? branch_stn_ids[1]\n            : branch_stn_ids[0];\n    return split_loop_stns_with_branch(loopline, branch_stn_id, bottom_factor, left_and_right_factor);\n};\n\nexport type LoopStns = ReturnType<typeof split_loop_stns>;\n\n/**\n * Calculate the xshares and yshares of the loop stations.\n *\n * @param loopline The loop line aka branches[0].\n * @param loop_stns Object returned from split_loop_stns.\n * @returns Values sit between 0 and 1.\n */\nexport const get_xshares_yshares_of_loop = (loopline: string[], loop_stns: LoopStns) => {\n    const x_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n    const y_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n\n    const [Y_TOP, Y_BOTTOM, X_LEFT, X_RIGHT] = [0, 1, 0, 1];\n\n    // loop's inner padding for xs\n    const e = 0; // 0 <= e <= 1\n\n    loop_stns.top.forEach((stn_id, i) => {\n        x_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.top.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_TOP;\n    });\n    loop_stns.right.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_RIGHT;\n        y_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.right.length + 1)) * (i + 1);\n    });\n    loop_stns.bottom.forEach((stn_id, i) => {\n        x_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.bottom.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_BOTTOM;\n    });\n    loop_stns.left.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_LEFT;\n        y_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.left.length + 1)) * (i + 1);\n    });\n\n    return {\n        x_shares: x_shares,\n        y_shares: y_shares,\n    };\n};\n\n/**\n * Get pivot stations from the loop line.\n */\nexport const get_pivot_stations = (\n    branches: string[][],\n    direction: ShortDirection,\n    stn_list: StationDict,\n    current_stn_id: string\n) => {\n    const loop_line = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const _ = [...loop_line, ...loop_line, ...loop_line];\n    const non_undefined_loop_line = direction === 'r' ? _ : _.reverse();\n    const current_stn_idx = non_undefined_loop_line.findIndex(stn_id => current_stn_id === stn_id) + loop_line.length;\n    return non_undefined_loop_line\n        .slice(current_stn_idx + 1)\n        .filter(stn_id => stn_list[stn_id].loop_pivot)\n        .slice(undefined, 2);\n};\n","import { CanvasType, Theme } from '../constants/constants';\nimport React, { ReactNode } from 'react';\n\ninterface SvgWrapperProps {\n    type: CanvasType;\n    svgWidth: number;\n    svgHeight: number;\n    canvasScale: number;\n    theme: Theme;\n    children: ReactNode;\n}\n\nexport default function SvgWrapper(props: SvgWrapperProps) {\n    const { type, svgWidth, svgHeight, canvasScale, theme, children } = props;\n\n    return (\n        <svg\n            id={type}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n            height={svgHeight * canvasScale}\n            viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n            colorInterpolationFilters=\"sRGB\"\n            style={{\n                ['--rmg-svg-width' as any]: svgWidth + 'px',\n                ['--rmg-svg-height' as any]: svgHeight + 'px',\n                ['--rmg-theme-colour' as any]: theme[2],\n                ['--rmg-theme-fg' as any]: theme[3],\n            }}\n        >\n            <rect\n                id=\"canvas-bg\"\n                fill=\"white\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n            {children}\n            <rect\n                id=\"canvas-border\"\n                fill=\"none\"\n                strokeWidth={3}\n                stroke=\"none\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n        </svg>\n    );\n}\n"],"names":["CANVAS_TYPE","CanvasType","DestinationSHMetro","canvasScale","useRootSelector","state","app","store","param","svgWidths","svgWidth","svgHeight","svg_height","theme","type","DefsSHMetro","DestSHMetro","memo","id","viewBox","refY","d","fill","helper","routes","branches","line_name","current_stn_id","current_stn_idx","direction","stn_list","info_panel_type","loop","coline","get_valid_destinations","Set","filter","route","includes","map","res","stn_id","reverse","get_dest_names","dest_ids","one_line","name","join","s","replace","valid_dest_ids","get_pivot_stations","coline_dest_ids","valid_dest_id","slice","branch","isColineBranch","some","dest_names","console","log","coline_dest_names","colines","Object","fromEntries","coline_dest_id","values","co","from","to","at","Dest","line_color","length","upper","transform","colors","props","platform_num","terminalEl","useRef","useState","width","terminalBBox","setTerminalBBox","useEffect","current","getBBox","JSON","stringify","middle","destination","platformX","PLATFORM_WIDTH","stroke","strokeWidth","markerEnd","undefined","Terminal","ref","PlatformNum","match","LineNameBoxNumber","LineNameBoxText","forwardRef","textAnchor","i","className","fontSize","dy","useMemo","r","dominantBaseline","x","boxX","stnNameEl","React","bBox","setBBox","rectDx","stnNameEnDx","height","lineNumber","lineNameRes","letterSpacing","split_loop_stns","loopline","bottom_factor","left_and_right_factor","top_factor","findIndex","val","non_undefined_loopline","split_a","Math","floor","split_b","top","left","right","bottom","split_loop_stns_with_branch","branch_stn_id","another_branch_stn_id","split_loop_stns_with_branches","branch_stn_ids","arc","top_a","top_b","stn","max","min","get_xshares_yshares_of_loop","loop_stns","x_shares","y_shares","forEach","e","loop_line","_","non_undefined_loop_line","loop_pivot","SvgWrapper","children","xmlns","xmlnsXlink","colorInterpolationFilters","style"],"sourceRoot":""}