{"version":3,"file":"static/js/1882.8a69df9d.chunk.js","mappings":"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","sources":["svgs/railmap/methods/shmetro-loop.test.ts","svgs/railmap/methods/shmetro-loop.ts"],"sourcesContent":["import { ShortDirection, StationDict } from '../../../constants/constants';\nimport {\n    split_loop_stns,\n    split_loop_stns_with_branch,\n    split_loop_stns_with_branches,\n    get_pivot_stations,\n} from './shmetro-loop';\n\nconst table = Array.from(new Array(20), (x, i) => i + 2)\n    .map(i => [...Array(i).keys()].map(i => String.fromCharCode(i + 97)))\n    .map(loopline => loopline.map(stn_id => ({ loopline: loopline, current_stn_id: stn_id })))\n    .flat()\n    .map(_ =>\n        Array.from(new Array(_.loopline.length - 1), (x, i) => i + 1).map(bottom_factor => ({\n            ..._,\n            bottom_factor: bottom_factor,\n            left_and_right_factor: Math.floor((_.loopline.length - bottom_factor * 2) / 2),\n        }))\n    )\n    .flat()\n    .filter(_ => _.bottom_factor > 0 && _.left_and_right_factor >= 0 && _.bottom_factor + _.left_and_right_factor > 0);\n\nconst branch_table = [\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'b',\n        bottom_factor: 1,\n        left_and_right_factor: 1,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'b',\n        bottom_factor: 0,\n        left_and_right_factor: 1,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'b',\n        bottom_factor: 1,\n        left_and_right_factor: 0,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'b',\n        bottom_factor: 2,\n        left_and_right_factor: 0,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'b',\n        bottom_factor: 0,\n        left_and_right_factor: 2,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'd',\n        bottom_factor: 1,\n        left_and_right_factor: 1,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'd',\n        bottom_factor: 0,\n        left_and_right_factor: 1,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'd',\n        bottom_factor: 1,\n        left_and_right_factor: 0,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'd',\n        bottom_factor: 2,\n        left_and_right_factor: 0,\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_id: 'd',\n        bottom_factor: 0,\n        left_and_right_factor: 2,\n    },\n];\n\nconst branches_table = [\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['b', 'd'],\n        left_and_right_factor: 0,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['b', 'd'],\n        left_and_right_factor: 0,\n        arc: 'minor',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['a', 'c'],\n        left_and_right_factor: 0,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['c', 'a'],\n        left_and_right_factor: 0,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['b', 'c'],\n        left_and_right_factor: 0,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e'],\n        branch_stn_ids: ['a', 'e'],\n        left_and_right_factor: 0,\n        arc: 'minor',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e', 'f'],\n        branch_stn_ids: ['b', 'e'],\n        left_and_right_factor: 1,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e', 'f'],\n        branch_stn_ids: ['e', 'b'],\n        left_and_right_factor: 1,\n        arc: 'major',\n    },\n    {\n        loopline: ['a', 'b', 'c', 'd', 'e', 'f'],\n        branch_stn_ids: ['d', 'c'],\n        left_and_right_factor: 1,\n        arc: 'minor',\n    },\n] as {\n    loopline: string[];\n    branch_stn_ids: [string, string];\n    left_and_right_factor: number;\n    arc: 'major' | 'minor';\n}[];\n\ndescribe('Unit tests for loop methods', () => {\n    it.each(table)(\n        'Correctly split loop stations',\n        ({ loopline, current_stn_id, bottom_factor, left_and_right_factor }) => {\n            const loop_stns = split_loop_stns(loopline, current_stn_id, bottom_factor, left_and_right_factor);\n\n            // every side is valid\n            expect(loop_stns.top.length).toBeGreaterThanOrEqual(1);\n            expect(loop_stns.right.length).toBeGreaterThanOrEqual(left_and_right_factor);\n            expect(loop_stns.bottom.length).toBeGreaterThanOrEqual(bottom_factor);\n            expect(loop_stns.left.length).toBeGreaterThanOrEqual(left_and_right_factor);\n\n            // Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n            // it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n            const _ = [...loop_stns.top, ...loop_stns.right, ...loop_stns.left, ...loop_stns.bottom];\n            expect(_.length).toBe(loopline.length);\n\n            // expect arrays to be equal ignoring order\n            expect(_.sort()).toEqual(loopline.sort());\n        }\n    );\n\n    it.each(branch_table)(\n        'Correctly split loop stations with one branch',\n        ({ loopline, branch_stn_id, bottom_factor, left_and_right_factor }) => {\n            const loop_stns = split_loop_stns_with_branch(\n                loopline,\n                branch_stn_id,\n                bottom_factor,\n                left_and_right_factor\n            );\n\n            // every side is valid\n            expect(loop_stns.top.length).toBeGreaterThanOrEqual(1);\n            expect(loop_stns.right.length).toBeGreaterThanOrEqual(left_and_right_factor);\n            expect(loop_stns.bottom.length).toBeGreaterThanOrEqual(bottom_factor);\n            expect(loop_stns.left.length).toBeGreaterThanOrEqual(left_and_right_factor);\n\n            // top side will start from branch_stn_id\n            expect(loop_stns.top.at(0)).toBe(branch_stn_id);\n\n            // Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n            // it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n            const _ = [...loop_stns.top, ...loop_stns.right, ...loop_stns.left, ...loop_stns.bottom];\n            expect(_.length).toBe(loopline.length);\n\n            // expect arrays to be equal ignoring order\n            expect(_.sort()).toEqual(loopline.sort());\n        }\n    );\n\n    it.each(branches_table)(\n        'Correctly split loop stations with two branches',\n        ({ loopline, branch_stn_ids, left_and_right_factor, arc }) => {\n            const loop_stns = split_loop_stns_with_branches(loopline, branch_stn_ids, left_and_right_factor, arc);\n\n            // every side is valid\n            expect(loop_stns.top.length).toBeGreaterThanOrEqual(1);\n            expect(loop_stns.right.length).toBeGreaterThanOrEqual(left_and_right_factor);\n            expect(loop_stns.bottom.length).toBeGreaterThanOrEqual(0);\n            expect(loop_stns.left.length).toBeGreaterThanOrEqual(left_and_right_factor);\n\n            // top side will start from branch_stn_ids[0] and end at branch_stn_ids[1]\n            expect(loop_stns.top.at(0)).toMatch(new RegExp(branch_stn_ids.join('|')));\n            expect(loop_stns.top.at(-1)).toMatch(new RegExp(branch_stn_ids.join('|')));\n\n            // Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n            // it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n            const _ = [...loop_stns.top, ...loop_stns.right, ...loop_stns.left, ...loop_stns.bottom];\n            expect(_.length).toBe(loopline.length);\n\n            // expect arrays to be equal ignoring order\n            expect(_.sort()).toEqual(loopline.sort());\n        }\n    );\n\n    it('Correctly get pivot stations', () => {\n        const branches = [['a', 'b', 'c', 'd', 'e']];\n        const stn_list = Object.fromEntries(branches[0].map(stn_id => [stn_id, { loop_pivot: false }])) as StationDict;\n\n        let pivots: string[];\n\n        // no error when no pivot is set\n        pivots = get_pivot_stations(branches, ShortDirection.left, stn_list, 'b');\n        expect(pivots.length).toBe(0);\n\n        // one pivot is not supported\n        // we just make sure no error is returned\n        stn_list['c'].loop_pivot = true;\n        pivots = get_pivot_stations(branches, ShortDirection.left, stn_list, 'b');\n        expect(pivots.length).toBe(1);\n        expect(pivots).toEqual(['c']);\n        pivots = get_pivot_stations(branches, ShortDirection.right, stn_list, 'b');\n        expect(pivots.length).toBe(2);\n        expect(pivots).toEqual(['c', 'c']);\n\n        stn_list['e'].loop_pivot = true;\n        pivots = get_pivot_stations(branches, ShortDirection.left, stn_list, 'b');\n        expect(pivots.length).toBe(2);\n        expect(pivots).toEqual(['e', 'c']);\n        pivots = get_pivot_stations(branches, ShortDirection.right, stn_list, 'b');\n        expect(pivots.length).toBe(2);\n        expect(pivots).toEqual(['c', 'e']);\n\n        pivots = get_pivot_stations(branches, ShortDirection.left, stn_list, 'e');\n        expect(pivots.length).toBe(2);\n        expect(pivots).toEqual(['c', 'e']);\n        pivots = get_pivot_stations(branches, ShortDirection.right, stn_list, 'e');\n        expect(pivots.length).toBe(2);\n        expect(pivots).toEqual(['c', 'e']);\n    });\n});\n","import { ShortDirection, StationDict } from '../../../constants/constants';\n\n/**\n * Split the loopline into four sides according to left_and_right_factor and bottom_factor.\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param current_stn_id Current station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns = (\n    loopline: string[],\n    current_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const current_stn_idx = loopline.findIndex(val => val === current_stn_id);\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + current_stn_idx - Math.floor(top_factor / 2) + (top_factor % 2 === 0 ? 1 : 0);\n    const split_b = loopline.length + current_stn_idx + Math.floor(top_factor / 2);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with one branch into four sides according to left_and_right_factor and bottom_factor.\n * Note that the top side must start from the branch_stn_id.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_id Branch station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branch = (\n    loopline: string[],\n    branch_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + loopline.findIndex(val => val === branch_stn_id);\n    const another_branch_stn_id = non_undefined_loopline[split_a + top_factor - 1];\n    const split_b =\n        loopline.length +\n        loopline.findIndex(val => val === another_branch_stn_id) +\n        (split_a + top_factor > loopline.length * 2 ? loopline.length : 0);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with two branches into four sides according to left_and_right_factor and arc.\n * Note that the top side must start from one of the branch_stn_ids and end at another.\n * Also the top side will be the major or the minor arc between branch_stn_ids.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > the major or the minor arc length between branch_stn_ids +\n *                          left_and_right_factor * 2\n *     2. left_and_right_factor >= 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_ids Branches station id.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @param arc Which arc will be the top side, the major or the minor.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branches = (\n    loopline: string[],\n    branch_stn_ids: [string, string],\n    left_and_right_factor: number,\n    arc: 'major' | 'minor'\n) => {\n    let split_a = loopline.findIndex(val => val === branch_stn_ids[0]);\n    let split_b = loopline.findIndex(val => val === branch_stn_ids[1]);\n    // swap a and b if a is bigger than b\n    [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]] =\n        split_a > split_b\n            ? [split_b, split_a, branch_stn_ids[1], branch_stn_ids[0]]\n            : [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]];\n    const top_a = loopline.slice(split_a, split_b + 1);\n    const top_b = loopline.filter(stn => !top_a.filter(stn => !branch_stn_ids.includes(stn)).includes(stn));\n    // which arc we use on the top will result to different bottom factor\n    const bottom_factor =\n        loopline.length -\n        (arc === 'major' ? Math.max : Math.min)(top_a.length, top_b.length) -\n        left_and_right_factor * 2;\n    const branch_stn_id =\n        arc === 'major'\n            ? top_a.length > top_b.length\n                ? branch_stn_ids[0]\n                : branch_stn_ids[1]\n            : top_a.length > top_b.length\n            ? branch_stn_ids[1]\n            : branch_stn_ids[0];\n    return split_loop_stns_with_branch(loopline, branch_stn_id, bottom_factor, left_and_right_factor);\n};\n\nexport type LoopStns = ReturnType<typeof split_loop_stns>;\n\n/**\n * Calculate the xshares and yshares of the loop stations.\n *\n * @param loopline The loop line aka branches[0].\n * @param loop_stns Object returned from split_loop_stns.\n * @returns Values sit between 0 and 1.\n */\nexport const get_xshares_yshares_of_loop = (loopline: string[], loop_stns: LoopStns) => {\n    const x_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n    const y_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n\n    const [Y_TOP, Y_BOTTOM, X_LEFT, X_RIGHT] = [0, 1, 0, 1];\n\n    // loop's inner padding for xs\n    const e = 0; // 0 <= e <= 1\n\n    loop_stns.top.forEach((stn_id, i) => {\n        x_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.top.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_TOP;\n    });\n    loop_stns.right.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_RIGHT;\n        y_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.right.length + 1)) * (i + 1);\n    });\n    loop_stns.bottom.forEach((stn_id, i) => {\n        x_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.bottom.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_BOTTOM;\n    });\n    loop_stns.left.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_LEFT;\n        y_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.left.length + 1)) * (i + 1);\n    });\n\n    return {\n        x_shares: x_shares,\n        y_shares: y_shares,\n    };\n};\n\n/**\n * Get pivot stations from the loop line.\n */\nexport const get_pivot_stations = (\n    branches: string[][],\n    direction: ShortDirection,\n    stn_list: StationDict,\n    current_stn_id: string\n) => {\n    const loop_line = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const _ = [...loop_line, ...loop_line, ...loop_line];\n    const non_undefined_loop_line = direction === 'r' ? _ : _.reverse();\n    const current_stn_idx = non_undefined_loop_line.findIndex(stn_id => current_stn_id === stn_id) + loop_line.length;\n    return non_undefined_loop_line\n        .slice(current_stn_idx + 1)\n        .filter(stn_id => stn_list[stn_id].loop_pivot)\n        .slice(undefined, 2);\n};\n"],"names":["table","Array","from","x","i","map","keys","String","fromCharCode","loopline","stn_id","current_stn_id","flat","_","length","bottom_factor","left_and_right_factor","Math","floor","filter","branch_table","branch_stn_id","branches_table","branch_stn_ids","arc","describe","it","each","loop_stns","split_loop_stns","expect","top","toBeGreaterThanOrEqual","right","bottom","left","toBe","sort","toEqual","split_loop_stns_with_branch","at","split_loop_stns_with_branches","toMatch","RegExp","join","pivots","branches","stn_list","Object","fromEntries","loop_pivot","get_pivot_stations","ShortDirection","top_factor","current_stn_idx","findIndex","val","non_undefined_loopline","split_a","split_b","slice","another_branch_stn_id","top_a","top_b","stn","includes","max","min","get_xshares_yshares_of_loop","x_shares","y_shares","forEach","e","direction","loop_line","non_undefined_loop_line","reverse","undefined"],"sourceRoot":""}