{"version":3,"file":"static/js/8306.d5ec033e.chunk.js","mappings":"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","sources":["svgs/railmap/methods/shmetro-loop.ts"],"sourcesContent":["import { ShortDirection, StationDict } from '../../../constants/constants';\n\n/**\n * Split the loopline into four sides according to left_and_right_factor and bottom_factor.\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param current_stn_id Current station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns = (\n    loopline: string[],\n    current_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const current_stn_idx = loopline.findIndex(val => val === current_stn_id);\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + current_stn_idx - Math.floor(top_factor / 2) + (top_factor % 2 === 0 ? 1 : 0);\n    const split_b = loopline.length + current_stn_idx + Math.floor(top_factor / 2);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with one branch into four sides according to left_and_right_factor and bottom_factor.\n * Note that the top side must start from the branch_stn_id.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_id Branch station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branch = (\n    loopline: string[],\n    branch_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + loopline.findIndex(val => val === branch_stn_id);\n    const another_branch_stn_id = non_undefined_loopline[split_a + top_factor - 1];\n    const split_b =\n        loopline.length +\n        loopline.findIndex(val => val === another_branch_stn_id) +\n        (split_a + top_factor > loopline.length * 2 ? loopline.length : 0);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with two branches into four sides according to left_and_right_factor and arc.\n * Note that the top side must start from one of the branch_stn_ids and end at another.\n * Also the top side will be the major or the minor arc between branch_stn_ids.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > the major or the minor arc length between branch_stn_ids +\n *                          left_and_right_factor * 2\n *     2. left_and_right_factor >= 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_ids Branches station id.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @param arc Which arc will be the top side, the major or the minor.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branches = (\n    loopline: string[],\n    branch_stn_ids: [string, string],\n    left_and_right_factor: number,\n    arc: 'major' | 'minor'\n) => {\n    let split_a = loopline.findIndex(val => val === branch_stn_ids[0]);\n    let split_b = loopline.findIndex(val => val === branch_stn_ids[1]);\n    // swap a and b if a is bigger than b\n    [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]] =\n        split_a > split_b\n            ? [split_b, split_a, branch_stn_ids[1], branch_stn_ids[0]]\n            : [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]];\n    const top_a = loopline.slice(split_a, split_b + 1);\n    const top_b = loopline.filter(stn => !top_a.filter(stn => !branch_stn_ids.includes(stn)).includes(stn));\n    // which arc we use on the top will result to different bottom factor\n    const bottom_factor =\n        loopline.length -\n        (arc === 'major' ? Math.max : Math.min)(top_a.length, top_b.length) -\n        left_and_right_factor * 2;\n    const branch_stn_id =\n        arc === 'major'\n            ? top_a.length > top_b.length\n                ? branch_stn_ids[0]\n                : branch_stn_ids[1]\n            : top_a.length > top_b.length\n            ? branch_stn_ids[1]\n            : branch_stn_ids[0];\n    return split_loop_stns_with_branch(loopline, branch_stn_id, bottom_factor, left_and_right_factor);\n};\n\nexport type LoopStns = ReturnType<typeof split_loop_stns>;\n\n/**\n * Calculate the xshares and yshares of the loop stations.\n *\n * @param loopline The loop line aka branches[0].\n * @param loop_stns Object returned from split_loop_stns.\n * @returns Values sit between 0 and 1.\n */\nexport const get_xshares_yshares_of_loop = (loopline: string[], loop_stns: LoopStns) => {\n    const x_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n    const y_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n\n    const [Y_TOP, Y_BOTTOM, X_LEFT, X_RIGHT] = [0, 1, 0, 1];\n\n    // loop's inner padding for xs\n    const e = 0; // 0 <= e <= 1\n\n    loop_stns.top.forEach((stn_id, i) => {\n        x_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.top.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_TOP;\n    });\n    loop_stns.right.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_RIGHT;\n        y_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.right.length + 1)) * (i + 1);\n    });\n    loop_stns.bottom.forEach((stn_id, i) => {\n        x_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.bottom.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_BOTTOM;\n    });\n    loop_stns.left.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_LEFT;\n        y_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.left.length + 1)) * (i + 1);\n    });\n\n    return {\n        x_shares: x_shares,\n        y_shares: y_shares,\n    };\n};\n\n/**\n * Get pivot stations from the loop line.\n */\nexport const get_pivot_stations = (\n    branches: string[][],\n    direction: ShortDirection,\n    stn_list: StationDict,\n    current_stn_id: string\n) => {\n    const loop_line = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const _ = [...loop_line, ...loop_line, ...loop_line];\n    const non_undefined_loop_line = direction === 'r' ? _ : _.reverse();\n    const current_stn_idx = non_undefined_loop_line.findIndex(stn_id => current_stn_id === stn_id) + loop_line.length;\n    return non_undefined_loop_line\n        .slice(current_stn_idx + 1)\n        .filter(stn_id => stn_list[stn_id].loop_pivot)\n        .slice(undefined, 2);\n};\n"],"names":["split_loop_stns","loopline","current_stn_id","bottom_factor","left_and_right_factor","top_factor","length","current_stn_idx","findIndex","val","non_undefined_loopline","split_a","Math","floor","split_b","top","slice","left","right","bottom","split_loop_stns_with_branch","branch_stn_id","another_branch_stn_id","split_loop_stns_with_branches","branch_stn_ids","arc","top_a","top_b","filter","stn","includes","max","min","get_xshares_yshares_of_loop","loop_stns","x_shares","Object","fromEntries","map","stn_id","y_shares","forEach","i","e","get_pivot_stations","branches","direction","stn_list","loop_line","_","non_undefined_loop_line","reverse","loop_pivot","undefined"],"sourceRoot":""}