{"version":3,"file":"static/js/destinationSHMetro.19946eb6.chunk.js","mappings":"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","sources":["svgs/destination/destination-shmetro.tsx","svgs/railmap/methods/shmetro-loop.ts"],"sourcesContent":["import React, { memo, useMemo, forwardRef, useRef, useState, useEffect } from 'react';\nimport { useRootSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { ColineInfo, ColourHex, MonoColour, Name, ShortDirection } from '../../constants/constants';\nimport { get_pivot_stations } from '../railmap/methods/shmetro-loop';\n\nexport default memo(function DestinationSHMetro() {\n    return (\n        <>\n            <DefsSHMetro />\n            <DestSHMetro />\n        </>\n    );\n});\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n    </defs>\n));\n\nconst DestSHMetro = () => {\n    const { routes, branches } = useRootSelector(store => store.helper);\n    const {\n        line_name,\n        theme,\n        current_stn_idx: current_stn_id,\n        direction,\n        stn_list,\n        info_panel_type,\n        loop,\n        coline,\n    } = useRootSelector(store => store.param);\n\n    // get valid destination of each branch\n    const get_valid_destinations = (routes: string[][], direction: ShortDirection, current_stn_id: string) => [\n        ...new Set(\n            routes\n                .filter(route => route.includes(current_stn_id))\n                .map(route => {\n                    const res = route.filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n                    return direction === 'l' ? res[0] : res.reverse()[0];\n                })\n        ),\n    ];\n    // get the name from the destination id(s)\n    const get_dest_names = (dest_ids: string[], one_line: boolean) =>\n        !one_line\n            ? dest_ids.map(id => stn_list[id].name.map(s => s.replace('\\\\', '')) as Name)\n            : [\n                  // only one line in `sh` type\n                  [\n                      dest_ids.map(id => stn_list[id].name[0]).join('，'),\n                      dest_ids.map(id => stn_list[id].name[1]).join(', '),\n                  ].map(s => s.replace('\\\\', '')) as Name,\n              ];\n\n    // get destination id(s)\n    const valid_dest_ids = !loop\n        ? get_valid_destinations(routes, direction, current_stn_id)\n        : get_pivot_stations(branches, direction, stn_list, current_stn_id);\n    // get coline destination id(s)\n    // note that for loop, coline branches' destination id(s) are needed\n    const coline_dest_ids = (!loop ? valid_dest_ids : get_valid_destinations(routes, direction, current_stn_id)).filter(\n        valid_dest_id =>\n            branches\n                .slice(1)\n                .filter(branch => isColineBranch(branch, stn_list))\n                .some(branch => branch.includes(valid_dest_id))\n    );\n    // filter out coline destination id(s)\n    const regular_dest_ids = valid_dest_ids.filter(valid_dest_id => !coline_dest_ids.includes(valid_dest_id));\n\n    // destination names of loop line, `sh2020` type will always be two lines\n    const dest_names = get_dest_names(regular_dest_ids, !loop && !(info_panel_type === 'sh2020'));\n    console.log(dest_names);\n    const coline_dest_names = get_dest_names(coline_dest_ids, true);\n\n    // this will give the space for at most two lines of dest_names\n    const coline_dy = 250;\n    // get coline info from coline_dest_ids\n    const colines = Object.fromEntries(\n        coline_dest_ids\n            .map(coline_dest_id => [\n                coline_dest_id,\n                Object.values(coline)\n                    .filter(co => co.from === coline_dest_id || co.to === coline_dest_id)\n                    .at(0),\n            ])\n            .filter(([key, val]) => val)\n    ) as {\n        [k: string]: ColineInfo;\n    };\n    return (\n        <>\n            <Dest\n                dest_names={dest_names}\n                line_name={line_name}\n                line_color={[theme[2], theme[3]]}\n                coline={coline_dest_ids.length ? true : false}\n                upper={coline_dest_ids.length ? true : false}\n            />\n            {coline_dest_ids.length &&\n                // multiple coline dest is not supported yet\n                coline_dest_ids.map(coline_dest_id => (\n                    <g key={`coline_${coline_dest_id}`} transform={`translate(0,${-coline_dy})`}>\n                        <Dest\n                            dest_names={[coline_dest_names.at(0)!]}\n                            line_name={colines[coline_dest_id]?.colors.at(0)!.slice(4) as Name}\n                            line_color={[\n                                colines[coline_dest_id]?.colors.at(0)![2],\n                                colines[coline_dest_id]?.colors.at(0)![3],\n                            ]}\n                            coline\n                            upper={false}\n                        />\n                    </g>\n                ))}\n        </>\n    );\n};\n\nconst Dest = (props: {\n    dest_names: Name[];\n    line_name: Name;\n    line_color: [ColourHex, MonoColour]; // override coline color\n    coline: boolean; // hide the marker if it is a coline\n    upper: boolean; // coline needs the line in the upper position\n}) => {\n    const { dest_names, line_name, line_color, coline, upper } = props;\n    const {\n        current_stn_idx: current_stn_id,\n        direction,\n        platform_num,\n        svgWidth,\n        svg_height,\n    } = useRootSelector(store => store.param);\n\n    const terminalEl = useRef<SVGGElement | null>(null);\n    const [terminalBBox, setTerminalBBox] = useState({ width: 0 } as SVGRect);\n    useEffect(\n        () => setTerminalBBox(terminalEl.current!.getBBox()),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [JSON.stringify(dest_names), JSON.stringify(current_stn_id)]\n    );\n\n    const [middle, MARGIN, PADDING, LINEBOX_WIDTH, PLATFORM_WIDTH] = [svgWidth.destination / 2, 10, 36, 264, 325];\n    // Alignment Priority:\n    // 1. Centre of canvas\n    // 2. Centre of remaining\n    const platformX =\n        middle - MARGIN - PADDING - terminalBBox.width >= PLATFORM_WIDTH / 2 &&\n        middle - MARGIN - PADDING - LINEBOX_WIDTH >= PLATFORM_WIDTH / 2\n            ? middle\n            : direction === 'l'\n            ? (svgWidth.destination + terminalBBox.width - LINEBOX_WIDTH) / 2\n            : (svgWidth.destination - terminalBBox.width + LINEBOX_WIDTH) / 2;\n\n    // the platform screen doors flash light\n    // #20\n    // $('g#station_info_shmetro > rect').attr({ transform: `translate(${this._svgDestWidth / 2},${250 + dh})` })\n\n    return (\n        <g transform={`translate(0,${svg_height - 300})`}>\n            <path\n                stroke={line_color[0]}\n                strokeWidth={12}\n                d={\n                    direction === 'l'\n                        ? `M${svgWidth.destination - 24},16 H 36`\n                        : `M24,16 H ${svgWidth.destination - 36}`\n                }\n                transform={`translate(0,${!upper ? 220 : -20})`}\n                markerEnd={!coline ? 'url(#slope)' : undefined}\n            />\n\n            <Terminal ref={terminalEl} dest_names={dest_names} />\n            {platform_num !== '' && (\n                <g transform={`translate(${platformX},0)`}>\n                    <PlatformNum />\n                </g>\n            )}\n\n            {line_name[0].match(/^[\\w\\d]+/) ? (\n                <LineNameBoxNumber line_name={line_name} line_color={line_color} />\n            ) : (\n                <LineNameBoxText line_name={line_name} line_color={line_color} />\n            )}\n        </g>\n    );\n};\n\nconst Terminal = forwardRef((props: { dest_names: Name[] }, ref: React.Ref<SVGGElement>) => {\n    const { dest_names } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    return (\n        <g ref={ref} transform={`translate(${direction === 'l' ? 36 : svgWidth.destination - 36},145)`}>\n            {/* this is not a generalized implementation, only dest length of 1 and 2 are supported */}\n            <g transform={`translate(0,${dest_names.length === 2 ? -20 : 20})`}>\n                <path\n                    d=\"M60,60L0,0L60-60H100L55-15H160V15H55L100,60z\"\n                    fill=\"black\"\n                    transform={`rotate(${direction === 'l' ? 0 : 180})scale(0.8)`}\n                />\n            </g>\n            <g\n                textAnchor={direction === 'l' ? 'start' : 'end'}\n                transform={`translate(${direction === 'l' ? 128 + 20 : -128 - 20},25)`}\n            >\n                {dest_names.map((name, i) => (\n                    <React.Fragment key={i}>\n                        <text className=\"rmg-name__zh\" fontSize={70} dy={i * -100 + 7} key={`zh${i}`}>\n                            {'往' + name[0]}\n                        </text>\n                        <text className=\"rmg-name__en\" fontSize={25} dy={i * -100 + 40} key={`en${i}`}>\n                            {'To ' + name[1]}\n                        </text>\n                    </React.Fragment>\n                ))}\n            </g>\n        </g>\n    );\n});\n\nconst PlatformNum = () => {\n    const { platform_num } = useRootSelector(store => store.param);\n\n    // Total width: 325\n    return useMemo(\n        () => (\n            <g transform={`translate(${-325 / 2 + 60},150)`}>\n                <circle r={60} fill=\"none\" stroke=\"black\" strokeWidth={2} />\n                <text className=\"rmg-name__en\" dominantBaseline=\"central\" fontSize={120} textAnchor=\"middle\">\n                    {platform_num}\n                </text>\n                <text className=\"rmg-name__zh\" fontSize={100} dominantBaseline=\"central\" x={65}>\n                    站台\n                </text>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [platform_num]\n    );\n};\n\nconst LineNameBoxText = (props: { line_name: Name; line_color: [ColourHex, MonoColour] }) => {\n    const { line_name, line_color } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    const boxX = direction === 'l' ? svgWidth.destination - 42 : 42;\n\n    // get the exact station name width so that the\n    // line color rectangle can be the right width.\n    const stnNameEl = useRef<SVGGElement | null>(null);\n    // the original name position\n    const [bBox, setBBox] = React.useState({ width: 0 } as DOMRect);\n    React.useEffect(\n        () => setBBox(stnNameEl.current!.getBBox()),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [...line_name]\n    );\n\n    const rectDx = (direction === 'l' ? -bBox.width : 0) - 6;\n    const stnNameEnDx = ((direction === 'l' ? -1 : 1) * bBox.width) / 2;\n\n    return useMemo(\n        () => (\n            <g transform={`translate(${boxX},92)`}>\n                <rect fill={line_color[0]} x={rectDx} width={bBox.width + 10} height={120} />\n                <g textAnchor={direction === 'r' ? 'start' : 'end'} transform=\"translate(0,68)\" fill={line_color[1]}>\n                    <g ref={stnNameEl}>\n                        <text className=\"rmg-name__zh\" fontSize={68}>\n                            {line_name[0]}\n                        </text>\n                    </g>\n                    <text className=\"rmg-name__en\" fontSize={30} textAnchor=\"middle\" x={stnNameEnDx} dy={42}>\n                        {line_name[1]}\n                    </text>\n                </g>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [bBox, ...line_name, ...line_color, direction, svgWidth.destination]\n    );\n};\n\nconst LineNameBoxNumber = (props: { line_name: Name; line_color: [ColourHex, MonoColour] }) => {\n    const { line_name, line_color } = props;\n    const { direction, svgWidth } = useRootSelector(store => store.param);\n\n    const [lineNumber, lineNameRes] = line_name[0].match(/^[\\w\\d]+|.+/g) as string[];\n\n    // Number width: 108\n    // Text width: 136\n    // Gap: 20\n    // Left: 108/2 + 20 + 136 = 210\n    // Right: 108/2 = 54\n    const boxX = direction === 'l' ? svgWidth.destination - 36 - 210 : 36 + 54;\n\n    // Total width: 264\n    return useMemo(\n        () => (\n            <g transform={`translate(${boxX},92)`}>\n                <rect fill={line_color[0]} x={-54} width={108} height={120} />\n                <text\n                    className=\"rmg-name__zh\"\n                    fill={line_color[1]}\n                    fontSize={96}\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"central\"\n                    transform=\"translate(0,60)\"\n                    letterSpacing={-5}\n                >\n                    {lineNumber}\n                </text>\n                <g textAnchor=\"start\" transform=\"translate(74,68)\">\n                    <text className=\"rmg-name__zh\" fontSize={68}>\n                        {lineNameRes}\n                    </text>\n                    <text className=\"rmg-name__en\" fontSize={30} dy={42}>\n                        {line_name[1]}\n                    </text>\n                </g>\n            </g>\n        ),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [boxX, ...line_name, ...line_color, direction, svgWidth.destination]\n    );\n};\n","import { ShortDirection, StationDict } from '../../../constants/constants';\n\n/**\n * Split the loopline into four sides according to left_and_right_factor and bottom_factor.\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param current_stn_id Current station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns = (\n    loopline: string[],\n    current_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const current_stn_idx = loopline.findIndex(val => val === current_stn_id);\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + current_stn_idx - Math.floor(top_factor / 2) + (top_factor % 2 === 0 ? 1 : 0);\n    const split_b = loopline.length + current_stn_idx + Math.floor(top_factor / 2);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with one branch into four sides according to left_and_right_factor and bottom_factor.\n * Note that the top side must start from the branch_stn_id.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > bottom_factor + left_and_right_factor * 2\n *     2. bottom_factor >= 0\n *     3. left_and_right_factor >= 0\n *     4. left_and_right_factor + bottom_factor > 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_id Branch station id.\n * @param bottom_factor How many stations the bottom side will have.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branch = (\n    loopline: string[],\n    branch_stn_id: string,\n    bottom_factor: number,\n    left_and_right_factor: number\n) => {\n    const top_factor = loopline.length - left_and_right_factor * 2 - bottom_factor;\n    const non_undefined_loopline = [...loopline, ...loopline, ...loopline];\n    const split_a = loopline.length + loopline.findIndex(val => val === branch_stn_id);\n    const another_branch_stn_id = non_undefined_loopline[split_a + top_factor - 1];\n    const split_b =\n        loopline.length +\n        loopline.findIndex(val => val === another_branch_stn_id) +\n        (split_a + top_factor > loopline.length * 2 ? loopline.length : 0);\n    return {\n        top: non_undefined_loopline.slice(split_a, split_b + 1),\n        left: non_undefined_loopline.slice(split_a - left_and_right_factor, split_a),\n        right: non_undefined_loopline.slice(split_b + 1, split_b + 1 + left_and_right_factor),\n        bottom: non_undefined_loopline.slice(\n            split_b + 1 + left_and_right_factor,\n            split_b + 1 + left_and_right_factor + bottom_factor\n        ),\n    };\n};\n\n/**\n * Split the loopline with two branches into four sides according to left_and_right_factor and arc.\n * Note that the top side must start from one of the branch_stn_ids and end at another.\n * Also the top side will be the major or the minor arc between branch_stn_ids.\n *\n * It assumes parameters will follow these rules:\n *     1. loopline.length > the major or the minor arc length between branch_stn_ids +\n *                          left_and_right_factor * 2\n *     2. left_and_right_factor >= 0\n *\n * @param loopline The loop line aka branches[0].\n * @param branch_stn_ids Branches station id.\n * @param left_and_right_factor How many stations the left and right side will have.\n * @param arc Which arc will be the top side, the major or the minor.\n * @returns Each array returned should be consecutive, and when combined in top -> right -> bottom -> left order,\n * it will also be consecutive. Note that the length of right, bottom, and left can be 0.\n */\nexport const split_loop_stns_with_branches = (\n    loopline: string[],\n    branch_stn_ids: [string, string],\n    left_and_right_factor: number,\n    arc: 'major' | 'minor'\n) => {\n    let split_a = loopline.findIndex(val => val === branch_stn_ids[0]);\n    let split_b = loopline.findIndex(val => val === branch_stn_ids[1]);\n    // swap a and b if a is bigger than b\n    [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]] =\n        split_a > split_b\n            ? [split_b, split_a, branch_stn_ids[1], branch_stn_ids[0]]\n            : [split_a, split_b, branch_stn_ids[0], branch_stn_ids[1]];\n    const top_a = loopline.slice(split_a, split_b + 1);\n    const top_b = loopline.filter(stn => !top_a.filter(stn => !branch_stn_ids.includes(stn)).includes(stn));\n    // which arc we use on the top will result to different bottom factor\n    const bottom_factor =\n        loopline.length -\n        (arc === 'major' ? Math.max : Math.min)(top_a.length, top_b.length) -\n        left_and_right_factor * 2;\n    const branch_stn_id =\n        arc === 'major'\n            ? top_a.length > top_b.length\n                ? branch_stn_ids[0]\n                : branch_stn_ids[1]\n            : top_a.length > top_b.length\n            ? branch_stn_ids[1]\n            : branch_stn_ids[0];\n    return split_loop_stns_with_branch(loopline, branch_stn_id, bottom_factor, left_and_right_factor);\n};\n\nexport type LoopStns = ReturnType<typeof split_loop_stns>;\n\n/**\n * Calculate the xshares and yshares of the loop stations.\n *\n * @param loopline The loop line aka branches[0].\n * @param loop_stns Object returned from split_loop_stns.\n * @returns Values sit between 0 and 1.\n */\nexport const get_xshares_yshares_of_loop = (loopline: string[], loop_stns: LoopStns) => {\n    const x_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n    const y_shares = Object.fromEntries(loopline.map(stn_id => [stn_id, -1]));\n\n    const [Y_TOP, Y_BOTTOM, X_LEFT, X_RIGHT] = [0, 1, 0, 1];\n\n    // loop's inner padding for xs\n    const e = 0; // 0 <= e <= 1\n\n    loop_stns.top.forEach((stn_id, i) => {\n        x_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.top.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_TOP;\n    });\n    loop_stns.right.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_RIGHT;\n        y_shares[stn_id] = e / 2 + ((1 - e) / (loop_stns.right.length + 1)) * (i + 1);\n    });\n    loop_stns.bottom.forEach((stn_id, i) => {\n        x_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.bottom.length + 1)) * (i + 1);\n        y_shares[stn_id] = Y_BOTTOM;\n    });\n    loop_stns.left.forEach((stn_id, i) => {\n        x_shares[stn_id] = X_LEFT;\n        y_shares[stn_id] = 1 - e / 2 - ((1 - e) / (loop_stns.left.length + 1)) * (i + 1);\n    });\n\n    return {\n        x_shares: x_shares,\n        y_shares: y_shares,\n    };\n};\n\n/**\n * Get pivot stations from the loop line.\n */\nexport const get_pivot_stations = (\n    branches: string[][],\n    direction: ShortDirection,\n    stn_list: StationDict,\n    current_stn_id: string\n) => {\n    const loop_line = branches[0].filter(stn_id => !['linestart', 'lineend'].includes(stn_id));\n    const _ = [...loop_line, ...loop_line, ...loop_line];\n    const non_undefined_loop_line = direction === 'r' ? _ : _.reverse();\n    const current_stn_idx = non_undefined_loop_line.findIndex(stn_id => current_stn_id === stn_id) + loop_line.length;\n    return non_undefined_loop_line\n        .slice(current_stn_idx + 1)\n        .filter(stn_id => stn_list[stn_id].loop_pivot)\n        .slice(undefined, 2);\n};\n"],"names":["memo","DefsSHMetro","DestSHMetro","id","viewBox","refY","d","fill","useRootSelector","store","helper","routes","branches","param","line_name","theme","current_stn_id","current_stn_idx","direction","stn_list","info_panel_type","loop","coline","get_valid_destinations","Set","filter","route","includes","map","res","stn_id","reverse","get_dest_names","dest_ids","one_line","name","join","s","replace","valid_dest_ids","get_pivot_stations","coline_dest_ids","valid_dest_id","slice","branch","isColineBranch","some","dest_names","console","log","coline_dest_names","colines","Object","fromEntries","coline_dest_id","values","co","from","to","at","Dest","line_color","length","upper","transform","colors","props","platform_num","svgWidth","svg_height","terminalEl","useRef","useState","width","terminalBBox","setTerminalBBox","useEffect","current","getBBox","JSON","stringify","middle","destination","platformX","PLATFORM_WIDTH","stroke","strokeWidth","markerEnd","undefined","Terminal","ref","PlatformNum","match","LineNameBoxNumber","LineNameBoxText","forwardRef","textAnchor","i","className","fontSize","dy","useMemo","r","dominantBaseline","x","boxX","stnNameEl","React","bBox","setBBox","rectDx","stnNameEnDx","height","lineNumber","lineNameRes","letterSpacing","split_loop_stns","loopline","bottom_factor","left_and_right_factor","top_factor","findIndex","val","non_undefined_loopline","split_a","Math","floor","split_b","top","left","right","bottom","split_loop_stns_with_branch","branch_stn_id","another_branch_stn_id","split_loop_stns_with_branches","branch_stn_ids","arc","top_a","top_b","stn","max","min","get_xshares_yshares_of_loop","loop_stns","x_shares","y_shares","forEach","e","loop_line","_","non_undefined_loop_line","loop_pivot"],"sourceRoot":""}