{"version":3,"file":"static/js/9014.7ceb11e2.chunk.js","mappings":"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","sources":["svgs/common/svg-wrapper.tsx","svgs/mtr/line-diagram-utils.ts","svgs/railmap/methods/mtr.ts","svgs/railmap/methods/share.ts"],"sourcesContent":["import { CanvasType, Theme } from '../../constants/constants';\nimport React, { ReactNode } from 'react';\n\ninterface SvgWrapperProps {\n    type: CanvasType;\n    svgWidth: number;\n    svgHeight: number;\n    canvasScale: number;\n    theme: Theme;\n    children: ReactNode;\n}\n\nexport default function SvgWrapper(props: SvgWrapperProps) {\n    const { type, svgWidth, svgHeight, canvasScale, theme, children } = props;\n\n    return (\n        <svg\n            id={type}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n            height={svgHeight * canvasScale}\n            viewBox={`0 0 ${svgWidth} ${svgHeight}`}\n            colorInterpolationFilters=\"sRGB\"\n            style={{\n                ['--rmg-svg-width' as any]: svgWidth + 'px',\n                ['--rmg-svg-height' as any]: svgHeight + 'px',\n                ['--rmg-theme-colour' as any]: theme[2],\n                ['--rmg-theme-fg' as any]: theme[3],\n            }}\n        >\n            <rect\n                id=\"canvas-bg\"\n                fill=\"white\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n            {children}\n            <rect\n                id=\"canvas-border\"\n                fill=\"none\"\n                strokeWidth={3}\n                stroke=\"none\"\n                style={{ height: 'var(--rmg-svg-height)', width: 'var(--rmg-svg-width)' }}\n            />\n        </svg>\n    );\n}\n","import { StationDict } from '../../constants/constants';\n\n/**\n * @return - negative: above main line, positive: below main line\n */\nexport const getStationYShare = (stationId: string, branches: string[][], stationList: StationDict): number => {\n    const mainBranch = branches[0];\n\n    if (mainBranch.includes(stationId)) {\n        // on main branch\n        if (branches.slice(1).find(branch => branch.includes(stationId))) {\n            // node shared by multiple branches\n            return 0;\n        } else {\n            const openJawSiblingBranch = branches.slice(1).find(branch => {\n                const isLeftOpenJaw = branch[0] === 'linestart';\n                const hasSiblingBranchOpenJawOnTheLeft =\n                    mainBranch.indexOf(stationId) < mainBranch.indexOf(branch.slice(-1)[0]);\n\n                const isRightOpenJaw = branch.slice(-1)[0] === 'lineend';\n                const hasSiblingBranchOpenJawOnTheRight = mainBranch.indexOf(stationId) > mainBranch.indexOf(branch[0]);\n\n                return (\n                    (isLeftOpenJaw && hasSiblingBranchOpenJawOnTheLeft) ||\n                    (isRightOpenJaw && hasSiblingBranchOpenJawOnTheRight)\n                );\n            });\n\n            if (openJawSiblingBranch) {\n                // on main branch but open jaw\n                // NOTE: determine y share of node by children ordering, not by whether it's a branch or not (like GZMTR)\n                // TODO: Remove requirement on stationList arg\n                return stationList[openJawSiblingBranch[0]].children.indexOf(openJawSiblingBranch[1]) === 1 ? -1 : 1;\n            } else {\n                // pure main branch without siblings or main branch with sidings\n                return 0;\n            }\n        }\n    } else {\n        // on branch/sidings\n        const branchBelongsTo = branches.slice(1).find(branch => branch.includes(stationId));\n        if (branchBelongsTo) {\n            const isSiding = branchBelongsTo[0] !== 'linestart' && branchBelongsTo.slice(-1)[0] !== 'lineend';\n            if (isSiding) {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1.2 : -1.2;\n            } else {\n                return stationList[branchBelongsTo[0]].children.indexOf(branchBelongsTo[1]) === 1 ? 1 : -1;\n            }\n        } else {\n            // fallback\n            return 0;\n        }\n    }\n};\n\nexport const getSidingPath = (coords: [number, number][]): string => {\n    const TURNING_RADIUS = 6;\n    const RIGHT_DOWN_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const DOWN_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},${TURNING_RADIUS}`;\n    const RIGHT_UP_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,0,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n    const UP_RIGHT_ARC = `a${TURNING_RADIUS},${TURNING_RADIUS},0,0,1,${TURNING_RADIUS},-${TURNING_RADIUS}`;\n\n    let prevCoord: [number, number] | undefined;\n    let paths: string[] = [];\n\n    for (let coord of coords) {\n        if (!prevCoord) {\n            paths.push('M' + coord.join(','));\n        } else {\n            if (coord[1] === prevCoord[1]) {\n                // horizontal\n                paths.push('H' + coord[0]);\n            } else {\n                const midPointX = (coord[0] + prevCoord[0]) / 2 - (prevCoord[1] === 0 ? 0 : TURNING_RADIUS * 2);\n                paths.push('H' + midPointX);\n\n                if (coord[1] > prevCoord[1]) {\n                    // turn to below\n                    paths.push(RIGHT_DOWN_ARC);\n                    paths.push('V' + (coord[1] - TURNING_RADIUS));\n                    paths.push(DOWN_RIGHT_ARC);\n                } else {\n                    // turn to above\n                    paths.push(RIGHT_UP_ARC);\n                    paths.push('V' + (coord[1] + TURNING_RADIUS));\n                    paths.push(UP_RIGHT_ARC);\n                }\n\n                paths.push('H' + coord[0]);\n            }\n        }\n        // update prev coordinate\n        prevCoord = coord;\n    }\n\n    return paths.join(' ').replace(/( H([\\d.]+))+/g, ' H$2');\n};\n","import { Stations } from './share';\nimport { StationDict, StationInfo } from '../../../constants/constants';\nimport { getSidingPath } from '../../mtr/line-diagram-utils';\n\nexport const leftWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'l') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.4;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.4;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        // osi22 not end\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'l' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].parents.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].parents[0]].children.length === 2) res += 0.4;\n    return res;\n};\n\nexport const rightWideFactor = (stnList: StationDict, stnId: string) => {\n    var res = 0;\n    let { transfer } = stnList[stnId];\n    let ls = transfer.info.map(val => val.length);\n    if (transfer.tick_direc === 'r') {\n        // int3 or above\n        if (!ls[1] && ls[0] > 1) res += 0.4;\n        // osi except osi22\n        if (ls[1] && (ls[0] !== 1 || ls[1] !== 2)) res += 0.4;\n    }\n    if (ls[0] === 1 && ls[1] === 2) {\n        if (stnList[stnId].parents[0] !== 'linestart' && stnList[stnId].children[0] !== 'lineend') res += 0.8;\n    }\n    // let { type, tick_direc } = stnList[stnId].transfer;\n    // if (tick_direc === 'r' && ['int3', 'osi11', 'osi12', 'osi21', 'osi31'].includes(type)) res += 0.8;\n    if (stnList[stnId].children.length === 2) res += 0.2;\n    if (stnList[stnList[stnId].children[0]].parents.length === 2) res += 0.4;\n    return res;\n};\n\nexport class StationsMTR extends Stations {\n    protected leftWideFactor = (stnId: string) => {\n        return leftWideFactor(this.stnList, stnId);\n    };\n\n    protected rightWideFactor = (stnId: string) => {\n        return rightWideFactor(this.stnList, stnId);\n    };\n\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            const isSiding = branch[0] !== 'linestart' && branch.slice(-1)[0] !== 'lineend';\n\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            if (isSiding) {\n                linePaths.sidingMain.push(getSidingPath(lineMainStns.map(id => [xs[id], ys[id]])));\n                linePaths.sidingPass.push(getSidingPath(linePassStns.map(id => [xs[id], ys[id]])));\n            } else {\n                linePaths.main.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        lineMainStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n                linePaths.pass.push(\n                    new this({ stnList, criticalPath: cp })._linePath(\n                        linePassStns,\n                        lineXs,\n                        branches,\n                        xs,\n                        ys,\n                        branchSpacing,\n                        cp,\n                        e\n                    )\n                );\n            }\n        });\n\n        return linePaths;\n    }\n}\n\nexport class StationsSHMetro extends StationsMTR {\n    static drawLine(\n        branches: string[][],\n        stnStates: { [stnId: string]: -1 | 0 | 1 },\n        stnList: { [stnId: string]: StationInfo },\n        lineXs: [number, number],\n        xs: { [stnId: string]: number },\n        ys: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number = 0\n    ) {\n        let linePaths = {\n            main: [] as string[],\n            pass: [] as string[],\n            sidingMain: [] as string[],\n            sidingPass: [] as string[],\n        };\n\n        branches.forEach((branch, i) => {\n            branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n            var lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n            var linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n            if (lineMainStns.length === 1) {\n                linePassStns = branch;\n            }\n\n            if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n                // if two set disjoint\n                if (linePassStns[0] === branch[0]) {\n                    // -1 -1 1 1\n                    linePassStns.push(lineMainStns[0]);\n                } else if (\n                    lineMainStns[0] === branch[0] &&\n                    lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n                    linePassStns.length\n                ) {\n                    linePassStns = branch;\n                    lineMainStns = [];\n                } else {\n                    // 1 1 -1 -1\n                    linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n                }\n            }\n\n            linePaths.main.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    lineMainStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n            linePaths.pass.push(\n                new this({ stnList, criticalPath: cp })._linePath(\n                    linePassStns,\n                    lineXs,\n                    branches,\n                    xs,\n                    ys,\n                    branchSpacing,\n                    cp,\n                    e\n                )\n            );\n        });\n\n        return linePaths;\n    }\n}\n","import { ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n"],"names":["SvgWrapper","props","type","svgWidth","svgHeight","canvasScale","theme","children","id","xmlns","xmlnsXlink","height","viewBox","colorInterpolationFilters","style","fill","width","strokeWidth","stroke","getStationYShare","stationId","branches","stationList","mainBranch","includes","slice","find","branch","openJawSiblingBranch","isLeftOpenJaw","hasSiblingBranchOpenJawOnTheLeft","indexOf","isRightOpenJaw","hasSiblingBranchOpenJawOnTheRight","branchBelongsTo","getSidingPath","coords","prevCoord","RIGHT_DOWN_ARC","DOWN_RIGHT_ARC","RIGHT_UP_ARC","UP_RIGHT_ARC","paths","coord","push","midPointX","TURNING_RADIUS","join","replace","leftWideFactor","stnList","stnId","res","transfer","ls","info","map","val","length","tick_direc","parents","rightWideFactor","StationsMTR","stnStates","lineXs","xs","ys","branchSpacing","cp","e","linePaths","main","pass","sidingMain","sidingPass","forEach","i","isSiding","lineMainStns","filter","linePassStns","unshift","criticalPath","_linePath","Stations","StationsSHMetro","adjacencyList","leftW","rightW","Object","keys","reduce","acc","cur","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","child","maxLength","Math","max","getXShareMTR","branchOfStn","partSource","partSink","leftOpenJaw","lens","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","data","yShares","xShares","namePoss","pathTurnParams","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","stnPred","getYShare","stnIds","realXs","realYs","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","stations","drawLine"],"sourceRoot":""}