{"version":3,"file":"static/js/runinSHMetro.e1b525a2.chunk.js","mappings":"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","sources":["svgs/railmap/methods/share.ts","svgs/railmap/methods/shmetro-coline.ts","svgs/runin/runin-shmetro.tsx"],"sourcesContent":["import * as Global from '../../../methods';\nimport { RMGParam, ShortDirection, StationDict, StationInfo } from '../../../constants/constants';\n\n/**\n * Compute the adjacency list of the graph.\n * @param stnList Key-value pairs of station info\n * @param leftW Callback of left wide factor\n * @param rightW Callback of right wide factor\n */\nexport const adjacencyList = (\n    stnList: { [stnId: string]: StationInfo },\n    leftW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number,\n    rightW: (stnList: { [stnId: string]: StationInfo }, stnId: string) => number\n) => {\n    return Object.keys(stnList).reduce(\n        (acc, cur) => ({\n            ...acc,\n            [cur]: stnList[cur].children.reduce(\n                (a, c) => ({ ...a, [c]: 1 + leftW(stnList, c) + rightW(stnList, cur) }),\n                {}\n            ),\n        }),\n        {} as { [from: string]: { [to: string]: number } }\n    );\n};\n\n/**\n * Compute critical path and its length from `from` node to `to` node with critical path method.\n * @param from ID of station on the left\n * @param to ID of station on the right\n * @param adjMat Adjacency matrix in the form of `Object` returned from `adjacencyList` method.\n */\nexport const criticalPathMethod = (from: string, to: string, adjMat: ReturnType<typeof adjacencyList>) => {\n    if (from === to) {\n        return { len: 0, nodes: [from] };\n    }\n    let allLengths: number[] = [];\n    let criticalPaths: string[][] = [];\n    Object.keys(adjMat[from]).forEach(child => {\n        let cp = criticalPathMethod(child, to, adjMat);\n        if (cp.len < 0) return;\n        allLengths.push(adjMat[from][child] + cp.len);\n        cp.nodes.unshift(from);\n        criticalPaths.push(cp.nodes);\n    });\n    let maxLength = Math.max(...allLengths);\n    return {\n        len: maxLength,\n        nodes: criticalPaths[allLengths.indexOf(maxLength)],\n    };\n};\n\nexport const getXShareMTR = (stnId: string, adjMat: ReturnType<typeof adjacencyList>, branches: string[][]) => {\n    let criticalPath = criticalPathMethod('linestart', 'lineend', adjMat);\n    if (criticalPath.nodes.includes(stnId)) {\n        return criticalPathMethod(criticalPath.nodes[1], stnId, adjMat).len;\n    } else {\n        // must has 1 parent and 1 child only\n        let branchOfStn = branches.filter(branch => branch.includes(stnId))[0];\n\n        let partSource = stnId;\n        while (!criticalPath.nodes.includes(partSource)) {\n            partSource = branchOfStn[branchOfStn.indexOf(partSource) - 1];\n        }\n        let partSink = stnId;\n        while (!criticalPath.nodes.includes(partSink)) {\n            partSink = branchOfStn[branchOfStn.indexOf(partSink) + 1];\n        }\n\n        let leftOpenJaw = partSource === 'linestart';\n        let rightOpenJaw = partSink === 'lineend';\n\n        // expand to fit\n        let lens = [];\n        if (!leftOpenJaw && !rightOpenJaw) {\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, partSink, adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else if (leftOpenJaw) {\n            lens[0] = 0;\n            lens[1] = criticalPathMethod(criticalPath.nodes[1], partSink, adjMat).len;\n            lens[2] = criticalPathMethod(branchOfStn[1], stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, partSink, adjMat).len;\n        } else {\n            // right open jaw\n            lens[0] = criticalPathMethod(criticalPath.nodes[1], partSource, adjMat).len;\n            lens[1] = criticalPathMethod(partSource, criticalPath.nodes.slice(-2)[0], adjMat).len;\n            lens[2] = criticalPathMethod(partSource, stnId, adjMat).len;\n            lens[3] = criticalPathMethod(stnId, branchOfStn.slice(-2)[0], adjMat).len;\n        }\n        return lens[0] + (lens[2] * lens[1]) / (lens[2] + lens[3]);\n    }\n};\n\nconst getYShare = (stnId: string, stnList: { [stnId: string]: StationInfo }) => {\n    return Global.getYShareMTR(stnId, stnList);\n};\n\n/**\n * Vertical position (in pixels) of station icon related to vertical position of line.\n */\nexport const getYReal = (stnId: string, param: RMGParam) => {\n    return -getYShare(stnId, param.stn_list) * param.branch_spacing;\n};\n\nconst _isPredecessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx2 !== -1 && idx2 < idx1) return true;\n    }\n    return false;\n};\n\nconst _isSuccessor = (stnId1: string, stnId2: string, routes: string[][]) => {\n    for (let route of routes) {\n        let idx1 = route.indexOf(stnId1);\n        let idx2 = route.indexOf(stnId2);\n        if (idx1 !== -1 && idx1 < idx2) return true;\n    }\n    return false;\n};\n\nexport const getStnState = (\n    currentId: string,\n    routes: string[][],\n    direction: 'l' | 'r'\n): { [stnId: string]: -1 | 0 | 1 } => {\n    console.log(\"computing stations' states\");\n    return [...new Set(([] as string[]).concat(...routes))].reduce(\n        (acc, cur: string) => ({\n            ...acc,\n            [cur]:\n                cur === currentId\n                    ? 0\n                    : (\n                          direction === ShortDirection.right\n                              ? _isSuccessor(currentId, cur, routes)\n                              : _isPredecessor(currentId, cur, routes)\n                      )\n                    ? 1\n                    : -1,\n        }),\n        {}\n    );\n};\n\nexport class Stations {\n    yShares = {} as { [stnId: string]: number };\n    xShares = {} as { [stnId: string]: number };\n    namePoss = {} as { [stnId: string]: boolean };\n    stnList = {} as StationDict;\n    criticalPath = {} as { len: number; nodes: string[] };\n\n    constructor(data: { stnList?: any; criticalPath?: any }) {\n        this.stnList = data.stnList;\n        this.criticalPath = data.criticalPath;\n    }\n\n    /**\n     * Increment of the weight of in-bound edge of a station, which increases the horizontal interval from its parents.\n     */\n    protected leftWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Increment of the weight of out-bound edge of a station, which increases the horizontal interval from its children.\n     */\n    protected rightWideFactor = (stnId: string) => {\n        return 0;\n    };\n\n    /**\n     * Path weight from station 1 to station 2 (station 2 must be a child of station 1, otherwise return `-Infinity`).\n     */\n    public pathWeight = (stnId1: string, stnId2: string) => {\n        if (!this.stnList[stnId1].children.includes(stnId2)) {\n            return -Infinity;\n        }\n        return 1 + this.rightWideFactor(stnId1) + this.leftWideFactor(stnId2);\n    };\n\n    protected getYShare(stnId: string, branches?: string[][]): number {\n        if (stnId in this.yShares) return this.yShares[stnId];\n\n        if (\n            ['linestart', 'lineend'].includes(stnId) ||\n            this.stnList[stnId].parents.length > 1 ||\n            this.stnList[stnId].children.length > 1\n        ) {\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n        var stnPred = this.stnList[stnId].parents[0];\n        if (stnPred) {\n            // parent exist\n            if (this.stnList[stnPred].children.length === 1) {\n                // no sibling, then y same as parent\n                let res = this.getYShare(stnPred);\n                this.yShares[stnId] = res;\n                return res;\n            } else {\n                // sibling exists, then y depends on its idx of being children\n                let res: 1 | -1 = this.stnList[stnPred].children.indexOf(stnId) === 0 ? 1 : -1;\n                this.yShares[stnId] = res;\n                return res;\n            }\n        } else {\n            // no parent, must be linestart\n            this.yShares[stnId] = 0;\n            return 0;\n        }\n    }\n\n    static getYShares(stnList: StationDict, branches?: string[][]) {\n        console.log('computing y shares');\n        let stations = new this({ stnList });\n\n        Object.keys(stnList).forEach(stnId => {\n            if (['linestart', 'lineend'].includes(stnId)) return;\n            if (stnId in stations.yShares) return;\n            stations.getYShare(stnId, branches);\n        });\n\n        return stations.yShares;\n    }\n\n    /**\n     * Parameters of the arcs involved in the `<path>` element.\n     */\n    private pathTurnParams = (branchSpacing: number) => {\n        let tr = 35; // turning radius\n        let dx_a = tr / 2; // dx of a\n        let dy_a = tr - dx_a * Math.sqrt(3); // dy of a\n        let dy_l = branchSpacing - 2 * dy_a; // dy of l\n        let dx_l = dy_l * Math.sqrt(3); // dx of l\n        return { tr, dx_a, dy_a, dx_l, dy_l };\n    };\n\n    /**\n     * Path segment from a station towards its southeast (lower-right).\n     */\n    private pathTurnSE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,1 ${dx_a},${dy_a} l ${dx_l},${dy_l} a ${tr},${tr} 0 0,0 ${dx_a},${dy_a}`;\n    };\n\n    /**\n     * Path segment from a station towards its northeast (upper-right).\n     */\n    private pathTurnNE = (branchSpacing: number) => {\n        let { tr, dx_a, dy_a, dx_l, dy_l } = this.pathTurnParams(branchSpacing);\n        return `a ${tr},${tr} 0 0,0 ${dx_a},${-dy_a} l ${dx_l},${-dy_l} a ${tr},${tr} 0 0,1 ${dx_a},${-dy_a}`;\n    };\n\n    /**\n     * Generate `d` attribute of `<path>` element through all stations input.\n     */\n    protected _linePath(\n        stnIds: string[],\n        lineXs: [number, number],\n        branches: string[][],\n        realXs: { [stnId: string]: number },\n        realYs: { [stnId: string]: number },\n        branchSpacing: number,\n        cp: { len: number; nodes: string[] },\n        e: number\n    ) {\n        var [prevId, prevY, prevX] = [] as unknown as [string, number, number];\n        var path = [] as string[];\n\n        let { dx_a, dx_l } = this.pathTurnParams(branchSpacing);\n        let stnDX = dx_a + dx_l / 2;\n        let stnExtraH = ((lineXs[1] - lineXs[0]) / cp.len) * 2;\n        let stnSpareH = ((lineXs[1] - lineXs[0]) / cp.len - 2 * stnDX) / 2;\n        if (stnSpareH + stnExtraH < 0) {\n            console.warn(`SVG width too small! ${stnSpareH + stnExtraH}`);\n        }\n\n        stnIds.forEach(stnId => {\n            let x = realXs[stnId];\n            let y = realYs[stnId];\n            if (!prevY && prevY !== 0) {\n                [prevId, prevX, prevY] = [stnId, x, y];\n                if (stnIds.length === 1) {\n                    path.push(`M ${x},${y}`);\n                } else if (!branches[0].includes(stnId)) {\n                    // started from branch\n                    path.push(`M ${x},${y}`);\n                } else if (branches[0].includes(stnIds[1])) {\n                    // started from branching station, this is main line\n                    path.push(`M ${x},${y}`);\n                } else {\n                    // started form branching station, this is branch line\n                    if (realXs[stnIds[1]] > 0) {\n                        path.push(`M ${x},${y + e}`);\n                    }\n                    if (realYs[stnIds[1]] < 0) {\n                        path.push(`M ${x},${y - e}`);\n                    }\n                }\n                return;\n            }\n            if (y > prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnSE(branchSpacing));\n            } else if (y < prevY) {\n                path.push(\n                    y === 0\n                        ? `h ${x - prevX - stnExtraH * this.leftWideFactor(stnId) - stnSpareH - stnDX * 2}`\n                        : `h ${stnExtraH * this.rightWideFactor(prevId) + stnSpareH}`\n                );\n                path.push(this.pathTurnNE(branchSpacing));\n            }\n            path.push(`H ${x}`);\n            [prevId, prevX, prevY] = [stnId, x, y];\n        });\n\n        // simplify path\n        return path.join(' ').replace(/( H ([\\d.]+))+/g, ' H $2');\n    }\n}\n\nexport const drawLine = (branch: string[], stnStates: { [stnId: string]: -1 | 0 | 1 }) => {\n    branch = branch.filter(stnId => !['linestart', 'lineend'].includes(stnId));\n    let lineMainStns = branch.filter(stnId => stnStates[stnId] >= 0);\n    let linePassStns = branch.filter(stnId => stnStates[stnId] <= 0);\n\n    if (lineMainStns.length === 1) {\n        linePassStns = branch;\n    }\n\n    if (lineMainStns.filter(stnId => linePassStns.indexOf(stnId) !== -1).length === 0 && lineMainStns.length) {\n        // if two set disjoint\n        if (linePassStns[0] === branch[0]) {\n            // -1 -1 1 1\n            linePassStns.push(lineMainStns[0]);\n        } else if (\n            lineMainStns[0] === branch[0] &&\n            lineMainStns[lineMainStns.length - 1] === branch[branch.length - 1] &&\n            linePassStns.length\n        ) {\n            linePassStns = branch;\n            lineMainStns = [];\n        } else {\n            // 1 1 -1 -1\n            linePassStns.unshift(lineMainStns[lineMainStns.length - 1]);\n        }\n    }\n\n    return {\n        main: lineMainStns,\n        pass: linePassStns,\n    };\n};\n","import { ColineInfo, InterchangeInfo } from '../../../constants/constants';\nimport { drawLine } from './share';\n\nexport interface ColineLinePath {\n    main: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n    pass: {\n        linePath: string[];\n        colors: InterchangeInfo[];\n    }[];\n}\n\n/**\n * Return all stations from ColineInfo's `from` and `to` with coline color preserved.\n */\nexport const calculateColineStations = (colineInfoList: ColineInfo[], branches: string[][]) =>\n    colineInfoList\n        .map(coLine => {\n            const involvedBranches = branches.filter(\n                branch => branch.includes(coLine.from) && branch.includes(coLine.to)\n            );\n\n            // the current coLineInfo fall on two separate branches,\n            // which should not be possible in current design.\n            if (involvedBranches.length !== 1) return { linePath: [], colors: coLine.colors };\n\n            const branch = involvedBranches.flat();\n            const a = branch.indexOf(coLine.from);\n            const b = branch.indexOf(coLine.to);\n            const linePath = a < b ? branch.slice(a, b + 1) : branch.slice(b, a + 1);\n            return {\n                linePath: linePath,\n                colors: coLine.colors,\n            };\n        })\n        .filter(branchWithColine => branchWithColine.linePath.length !== 0);\n\n/**\n * Return coline segments with stations in main/pass order.\n */\nexport const calculateColine = (\n    branchWithColine: ReturnType<typeof calculateColineStations>,\n    stnStates: {\n        [stnId: string]: 0 | 1 | -1;\n    }\n) =>\n    branchWithColine\n        .map(branchWithColine => {\n            const linePaths = drawLine(branchWithColine.linePath, stnStates);\n            return {\n                main: [\n                    {\n                        linePath: linePaths.main,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n                pass: [\n                    {\n                        linePath: linePaths.pass,\n                        colors: branchWithColine.colors,\n                    },\n                ],\n            };\n        })\n        // .map(branchWithColine =>\n        //     (\n        //         Object.entries(drawLine(branchWithColine.linePath, stnStates)) as [\n        //             keyof ReturnType<typeof drawLine>,\n        //             string[]\n        //         ][]\n        //     )\n        //         .map(([type, linePath]) => ({ [type]: { linePath: linePath, colors: branchWithColine.colors } }))\n        //         .reduce((acc, cur) => ({ ...acc, ...cur }), { main: [], pass: [] } as ColineLinePath)\n        // )\n        .reduce(\n            (acc, cur) => {\n                acc.main = [...acc.main, ...cur.main];\n                acc.pass = [...acc.pass, ...cur.pass];\n                return acc;\n            },\n            { main: [], pass: [] } as ColineLinePath\n        );\n","import React, { useMemo, memo } from 'react';\nimport { Name, StationDict } from '../../constants/constants';\nimport { useRootSelector } from '../../redux';\nimport { isColineBranch } from '../../redux/param/coline-action';\nimport { calculateColineStations } from '../railmap/methods/shmetro-coline';\n\nconst LINE_WIDTH = 12;\n\nconst RunInSHMetro = () => {\n    const { branches, routes, depsStr: deps } = useRootSelector(store => store.helper);\n    const { svg_height, current_stn_idx, direction, loop } = useRootSelector(store => store.param);\n\n    // get the height\n    const dh = svg_height - 300;\n\n    const prevStnIds = useMemo(\n        () => {\n            let prevStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? 1 : -1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                prevStnIds.length === 1 && // and it is the first station of that direction\n                ['linestart', 'lineend'].includes(prevStnIds[0])\n            ) {\n                // get the station from the other end\n                prevStnIds = direction === 'l' ? [branches[0][1]] : [branches[0][branches[0].length - 2]];\n            }\n            return prevStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    const nextStnIds = useMemo(\n        () => {\n            let nextStnIds = routes\n                .filter(route => route.includes(current_stn_idx))\n                .map(route => route[route.indexOf(current_stn_idx) + (direction === 'l' ? -1 : 1)])\n                // .flat()\n                // remove duplicate\n                .reduce((acc, cur) => (acc.includes(cur) ? acc : acc.concat(cur)), [] as string[]);\n            if (\n                loop && // if it is a loop\n                branches[0].includes(current_stn_idx) && // and this station is on the loop line\n                nextStnIds.length === 1 && // and it is the last station of that direction\n                ['linestart', 'lineend'].includes(nextStnIds[0])\n            ) {\n                // get the station from the other end\n                nextStnIds = direction === 'l' ? [branches[0][branches[0].length - 2]] : [branches[0][1]];\n            }\n            return nextStnIds;\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [deps, current_stn_idx, direction, loop]\n    );\n\n    return (\n        <>\n            <DefsSHMetro />\n            <g transform={`translate(0,${dh})`}>\n                <GeneralStation prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            </g>\n        </>\n    );\n};\n\nexport default RunInSHMetro;\n\nconst DefsSHMetro = memo(() => (\n    <defs>\n        {/* An extension of the line/path. Remember to minus the stroke-width.  */}\n        <marker id=\"slope\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n            <path d=\"M0,0L1,1H-1z\" fill=\"var(--rmg-theme-colour)\" />\n        </marker>\n\n        {/* Outline filter of white pass color in Pujiang Line */}\n        <filter\n            id=\"pujiang_outline_runin\"\n            colorInterpolationFilters=\"sRGB\"\n            // TODO: remove the absolute value while make the filter works correctly\n            filterUnits=\"userSpaceOnUse\"\n            x=\"0\"\n            y=\"-1000\"\n            width=\"5000\"\n            height=\"2000\"\n        >\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"0\" result=\"e1\" />\n            <feMorphology operator=\"erode\" in=\"SourceAlpha\" radius=\"1\" result=\"e2\" />\n            <feComposite in=\"e1\" in2=\"e2\" operator=\"xor\" result=\"outline\" />\n            <feComposite in=\"outline\" in2=\"SourceGraphic\" operator=\"over\" result=\"output\" />\n        </filter>\n    </defs>\n));\n\ninterface RunInGeneralProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n}\n\nconst GeneralStation = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const { info_panel_type, svgWidth, stn_list } = useRootSelector(store => store.param);\n\n    const middle = svgWidth.runin / 2;\n    const terminal = nextStnIds.length === 1 && ['linestart', 'lineend'].includes(nextStnIds[0]);\n    const original = prevStnIds.length === 1 && ['linestart', 'lineend'].includes(prevStnIds[0]);\n\n    const nextNames = nextStnIds.map(stnId => stn_list[stnId].name);\n    const prevNames = prevStnIds.map(stnId => stn_list[stnId].name);\n\n    const nextBranchLineDy =\n        (nextStnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n    const prevBranchLineDy =\n        (prevStnIds.length > 1\n            ? (prevNames[0][0].split('\\\\').length - 1) * -50 + (prevNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 10;\n\n    return (\n        <>\n            <BranchLine\n                prevStnIds={prevStnIds}\n                nextStnIds={nextStnIds}\n                nextBranchLineDy={nextBranchLineDy}\n                prevBranchLineDy={prevBranchLineDy}\n            />\n\n            {terminal && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"terminal\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : original && info_panel_type !== 'sh2020' ? (\n                <TerminalStation mode=\"original\" prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n            ) : (\n                <>\n                    {/* General Station */}\n                    <Line prevStnIds={prevStnIds} nextStnIds={nextStnIds} />\n\n                    <g transform={`translate(${middle},160)`} textAnchor=\"middle\">\n                        <CurrentText />\n                    </g>\n                </>\n            )}\n\n            {(original || !terminal) && <NextStn stnIds={props.nextStnIds} />}\n            {(terminal || !original) && <PrevStn stnIds={props.prevStnIds} />}\n        </>\n    );\n};\n\nconst TerminalStation = (props: { mode: 'terminal' | 'original'; prevStnIds: string[]; nextStnIds: string[] }) => {\n    const { mode, prevStnIds, nextStnIds } = props;\n    const { current_stn_idx, theme, svgWidth, direction, coline } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n\n    const textProps = {\n        l: { original: { x: svgWidth.runin - 36, anchor: 'end' }, terminal: { x: 36, anchor: 'start' } },\n        r: { original: { x: 36, anchor: 'start' }, terminal: { x: svgWidth.runin - 36, anchor: 'end' } },\n    };\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n    const nextColineColorFrom = mode === 'terminal' ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    return (\n        <>\n            {mode === 'original' && (\n                <path\n                    transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                    stroke={nextColineColor}\n                    strokeWidth={12}\n                    d={direction === 'l' ? `M ${svgWidth.runin - 24},16 H 36` : `M24,16 H ${svgWidth.runin - 36}`}\n                    markerEnd=\"url(#slope)\"\n                />\n            )}\n\n            {mode === 'terminal' && (\n                <g filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}>\n                    <path\n                        transform={`translate(0,${coline.length ? '198' : '220'})${coline.length ? 'scale(1,2)' : ''}`}\n                        stroke=\"var(--rmg-grey)\"\n                        strokeWidth={12}\n                        d={`M24,16 H ${svgWidth.runin - 24}`}\n                    />\n                </g>\n            )}\n\n            <g\n                transform={`translate(${textProps[direction][mode].x},160)`}\n                textAnchor={textProps[direction][mode].anchor}\n            >\n                <CurrentText />\n            </g>\n        </>\n    );\n};\n\nconst Line = (props: RunInGeneralProps) => {\n    const { prevStnIds, nextStnIds } = props;\n    const {\n        direction,\n        svgWidth,\n        theme,\n        coline,\n        current_stn_idx,\n        stn_list: stnList,\n    } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    // determine the end with linestart/lineend or .length === 0\n    const isEnd = (stnIds: string[]) => stnIds.includes('linestart') || stnIds.includes('lineend');\n\n    const colineStns = calculateColineStations(Object.values(coline), branches);\n\n    // whether the next line is single color(var(--rmg-theme-colour) or coline color) or multiple colors\n    // let nextColineMode: 'single' | 'multiple' = 'single';\n    // TODO-coline: if coline is allowed in other segments, then this should be considered more precisely\n    const nextColineMode =\n        nextStnIds.length > 1\n            ? // needs to be single since BranchLine is in effect\n              'single'\n            : isEnd(nextStnIds)\n            ? colineStns.filter(co => [current_stn_idx, prevStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n                ? // if this the terminal station, look back to see if it falls in coline\n                  'multiple'\n                : 'single'\n            : [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) && // is in the main line\n              // and has coline from current_stn_idx to nextStnIds[0]\n              colineStns.filter(co => [current_stn_idx, nextStnIds[0]].every(stnId => co.linePath.includes(stnId)))\n                  .length > 0\n            ? 'multiple'\n            : 'single';\n\n    const nextColineColorFrom = isEnd(nextStnIds) ? prevStnIds : nextStnIds;\n    const nextColineColor =\n        nextStnIds.length > 1\n            ? 'var(--rmg-theme-colour)' // BranchLine will handle color of next line well\n            : colineStns\n                  .filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextColineColorFrom[0]))\n                  // TODO-coline: handle multiple coline colors\n                  .map(co => co.colors[0][2])[0] ?? 'var(--rmg-theme-colour)';\n\n    // curr and next/pass segment is in the coline branch\n    const isInColineBranch = (\n        branches: string[][],\n        current_stn_idx: string,\n        nextOrPassStnIds: string[],\n        stnList: StationDict\n    ) =>\n        branches\n            .slice(1)\n            .filter(branch => [current_stn_idx, nextOrPassStnIds[0]].every(stnId => branch.includes(stnId)))\n            .filter(branch => isColineBranch(branch, stnList)).length > 0;\n\n    // change color to coline color only if it has coline and the curr and next stations are in the coline branch\n    const nextColor =\n        Object.keys(coline).length > 0 && isInColineBranch(branches, current_stn_idx, nextStnIds, stnList)\n            ? nextColineColor\n            : 'var(--rmg-theme-colour)';\n\n    // stretch the next line element if curr and next stations aren't in main line with coline\n    const nextLineStretch =\n        Object.keys(coline).length > 0 &&\n        nextStnIds.length === 1 && // BranchLine will add branch next line so no stretch is needed\n        (isEnd(prevStnIds) || isEnd(nextStnIds)\n            ? true // terminal station with coline(prevent linestart/lineend)\n            : !(\n                  [current_stn_idx, nextStnIds[0]].every(stnId => branches[0].includes(stnId)) &&\n                  colineStns.filter(co => co.linePath.includes(current_stn_idx) && co.linePath.includes(nextStnIds[0]))\n                      .length !== 0\n              )); // no stretch if it is in main line with coline\n\n    // stretch the pass line element if BranchLine is not in effect\n    const passLineStretch = Object.keys(coline).length > 0 && prevStnIds.length === 1;\n\n    return (\n        <g transform=\"translate(0,220)\" strokeWidth={12}>\n            <>\n                {nextColor !== 'var(--rmg-theme-colour)' && (\n                    <marker id={`slope_${nextColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n                    </marker>\n                )}\n                <path\n                    stroke={nextColor}\n                    d={`M ${middle},16 H ${direction === 'l' ? 36 : svgWidth.runin - 36}`}\n                    // markerEnd=\"url(#slope)\"\n                    markerEnd={nextColor === 'var(--rmg-theme-colour)' ? 'url(#slope)' : `url(#slope_${nextColor})`}\n                    transform={nextLineStretch ? 'translate(0,-22)scale(1,2)' : undefined}\n                />\n            </>\n            {nextColineMode === 'multiple' && (\n                <>\n                    <marker id={`slope_${nextColineColor}`} viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                        <path d=\"M0,0L1,1H-1z\" fill={nextColineColor} />\n                    </marker>\n                    <path\n                        stroke={nextColineColor}\n                        d={`M ${middle},16 H ${\n                            direction === 'l' ? 36 + LINE_WIDTH : svgWidth.runin - (36 + LINE_WIDTH)\n                        }`}\n                        markerEnd={`url(#slope_${nextColineColor})`}\n                        transform=\"translate(0,-12)\"\n                    />\n                </>\n            )}\n\n            <g\n                filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n                transform={`translate(0,${passLineStretch ? -22 : 0})scale(1,${passLineStretch ? 2 : 1})`}\n            >\n                <path\n                    stroke=\"var(--rmg-grey)\"\n                    d={`M ${middle},16 H ${direction === 'l' ? svgWidth.runin - 24 : 24} `}\n                />\n            </g>\n        </g>\n    );\n};\n\ninterface RunInBranchLineProps {\n    prevStnIds: string[];\n    nextStnIds: string[];\n    nextBranchLineDy: number;\n    prevBranchLineDy: number;\n}\n\nconst BranchLine = (props: RunInBranchLineProps) => {\n    const { prevStnIds, nextStnIds, nextBranchLineDy, prevBranchLineDy } = props;\n\n    const { direction, svgWidth, current_stn_idx, coline, theme } = useRootSelector(store => store.param);\n    const { branches } = useRootSelector(store => store.helper);\n    const middle = svgWidth.runin / 2;\n\n    const LINE_BRANCH_Y = 125;\n\n    // draw a line between these dots\n    const dotToPos = (dot: [number, number]) => `${dot[0]},${dot[1]}`;\n    const dotsToPath = (dots: [number, number][]) =>\n        `M${dotToPos(dots.at(0)!)} ` +\n        dots\n            .slice(1)\n            .map(dot => `L${dotToPos(dot)}`)\n            .join(' ');\n\n    let nextDots = (\n        direction === 'l'\n            ? [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, nextBranchLineDy],\n                  [36, nextBranchLineDy],\n              ]\n            : [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, nextBranchLineDy],\n                  [svgWidth.runin - 36, nextBranchLineDy],\n              ]\n    ) as [number, number][];\n    let prevDots = (\n        direction === 'l'\n            ? [\n                  [(svgWidth.runin / 3) * 2, LINE_BRANCH_Y],\n                  [(svgWidth.runin / 6) * 5, prevBranchLineDy],\n                  [svgWidth.runin - 24, prevBranchLineDy],\n              ]\n            : [\n                  [svgWidth.runin / 3, LINE_BRANCH_Y],\n                  [svgWidth.runin / 6, prevBranchLineDy],\n                  [24, prevBranchLineDy],\n              ]\n    ) as [number, number][];\n\n    let nextColor = 'var(--rmg-theme-colour)';\n\n    if (Object.keys(coline).length > 0) {\n        const colineStns = calculateColineStations(Object.values(coline), branches);\n\n        // If the next stns have coline branch here,\n        // uplift branch a little bit with coline color.\n        if (\n            nextStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && nextStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            nextDots[0][1] -= LINE_WIDTH - 1;\n            nextDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n            nextColor = colineStns\n                .filter(\n                    stns =>\n                        stns.linePath.includes(current_stn_idx) &&\n                        nextStnIds.some(stnId => stns.linePath.includes(stnId))\n                )\n                // TODO-coline: known undefined issues when coline is removed if the station is removed via removeInvalidColineOnRemoveStation\n                .at(0)!\n                .colors.at(0)![2];\n        }\n\n        // If the prev stns have coline branch here,\n        // uplift branch a little bit.\n        if (\n            prevStnIds.length > 1 &&\n            colineStns.filter(\n                stns =>\n                    stns.linePath.includes(current_stn_idx) && prevStnIds.some(stnId => stns.linePath.includes(stnId))\n            )\n        ) {\n            // no idea why strokeWidth is 12 but only when dy = -11 will be perfect\n            prevDots[0][1] -= LINE_WIDTH - 1;\n            prevDots.unshift([middle, LINE_BRANCH_Y - LINE_WIDTH + 1]);\n        }\n    }\n\n    return (\n        <g\n            transform=\"translate(0,110)\"\n            strokeWidth={12}\n            fill=\"none\"\n            filter={theme[2] === '#999999' ? 'url(#pujiang_outline_runin)' : undefined}\n        >\n            {/* An extension of the line/path with coline color. */}\n            <marker id=\"slope_branch\" viewBox=\"-1.5 0 3 1.5\" refY={0.5}>\n                <path d=\"M0,0L1,1H-1z\" fill={nextColor} />\n            </marker>\n\n            {nextStnIds.length > 1 && (\n                <path stroke={nextColor} d={dotsToPath(nextDots)} markerEnd=\"url(#slope_branch)\" />\n            )}\n            {prevStnIds.length > 1 && <path stroke=\"var(--rmg-grey)\" d={dotsToPath(prevDots)} />}\n        </g>\n    );\n};\n\nconst CurrentText = () => {\n    const param = useRootSelector(store => store.param);\n    const { name } = param.stn_list[param.current_stn_idx];\n    return useMemo(\n        () => (\n            <>\n                <text className=\"rmg-name__zh\" fontSize={112}>\n                    {name[0].replace('\\\\', '')}\n                </text>\n                <text className=\"rmg-name__en\" fontSize={36} dy={50}>\n                    {name[1].replace('\\\\', '')}\n                </text>\n            </>\n        ),\n        [...name]\n    );\n};\n\nconst NextText = (props: { nextName: Name } & React.SVGProps<SVGGElement>) => {\n    const { nextName, ...others } = props;\n    return (\n        <g {...others}>\n            {useMemo(\n                () => (\n                    <>\n                        {nextName[0].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__zh\"\n                                fontSize={48}\n                                key={name}\n                                dy={(array.length - 1 - i) * -50 - (nextName[1].split('\\\\').length - 1) * 30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                        {nextName[1].split('\\\\').map((name, i, array) => (\n                            <text\n                                className=\"rmg-name__en\"\n                                fontSize={24}\n                                key={name}\n                                dy={28 + (array.length - 1 - i) * -30}\n                            >\n                                {name}\n                            </text>\n                        ))}\n                    </>\n                ),\n                [...nextName]\n            )}\n        </g>\n    );\n};\n\nconst PrevStn = (props: { stnIds: string[] }) => {\n    const param = useRootSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const prevHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            fill=\"gray\"\n            textAnchor={param.direction === 'l' ? 'end' : 'start'}\n            transform={`translate(${param.direction === 'l' ? param.svgWidth.runin - 36 : 36},0)`}\n        >\n            <NextText nextName={nextNames[0]} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText nextName={nextNames[1]} transform={`translate(0,${nextBranchTextDy})`} />\n            )}\n            <g transform={`translate(0, ${prevHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    上一站\n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? -70 : 70}>\n                    Past Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n\nconst NextStn = (props: { stnIds: string[] }) => {\n    const param = useRootSelector(store => store.param);\n    const nextNames = props.stnIds.map(stnId => param.stn_list[stnId].name);\n    const nextHintDy =\n        (props.stnIds.length > 1 ? 15 : 125) +\n        nextNames.map(name => name[0].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -50 +\n        nextNames.map(name => name[1].split('\\\\').length).reduce((acc, cur) => acc + cur, -nextNames.length) * -30;\n    const nextBranchTextDy =\n        (props.stnIds.length > 1\n            ? (nextNames[0][0].split('\\\\').length - 1) * -50 + (nextNames[0][1].split('\\\\').length - 1) * -30\n            : 0) + 70;\n\n    return (\n        <g\n            textAnchor={param.direction === 'l' ? 'start' : 'end'}\n            transform={`translate(${param.direction === 'l' ? 36 : param.svgWidth.runin - 36},0)`}\n        >\n            <NextText nextName={param.stn_list[props.stnIds[0]].name} transform=\"translate(0,183)\" />\n            {props.stnIds.length > 1 && (\n                <NextText\n                    nextName={param.stn_list[props.stnIds[1]].name}\n                    transform={`translate(0,${nextBranchTextDy})`}\n                />\n            )}\n            <g transform={`translate(0, ${nextHintDy})`}>\n                <text className=\"rmg-name__zh\" fontSize={22}>\n                    下一站\n                </text>\n                <text className=\"rmg-name__en\" fontSize={12} dx={param.direction === 'l' ? 70 : -70}>\n                    Next Stop\n                </text>\n            </g>\n        </g>\n    );\n};\n"],"names":["adjacencyList","stnList","leftW","rightW","Object","keys","reduce","acc","cur","children","a","c","criticalPathMethod","from","to","adjMat","len","nodes","allLengths","criticalPaths","forEach","child","cp","push","unshift","maxLength","Math","max","indexOf","getXShareMTR","stnId","branches","criticalPath","includes","branchOfStn","filter","branch","partSource","partSink","leftOpenJaw","lens","slice","getStnState","currentId","routes","direction","console","log","Set","concat","ShortDirection","stnId1","stnId2","route","idx1","idx2","_isSuccessor","_isPredecessor","Stations","data","yShares","xShares","namePoss","leftWideFactor","rightWideFactor","pathWeight","Infinity","pathTurnParams","branchSpacing","dy_a","tr","sqrt","dy_l","dx_a","dx_l","pathTurnSE","pathTurnNE","this","parents","length","stnPred","res","getYShare","stnIds","lineXs","realXs","realYs","e","prevId","prevY","prevX","path","stnDX","stnExtraH","stnSpareH","warn","x","y","join","replace","stations","drawLine","stnStates","lineMainStns","linePassStns","main","pass","calculateColineStations","colineInfoList","map","coLine","involvedBranches","linePath","colors","flat","b","branchWithColine","calculateColine","linePaths","useRootSelector","store","helper","deps","depsStr","param","svg_height","current_stn_idx","loop","dh","prevStnIds","useMemo","nextStnIds","DefsSHMetro","transform","GeneralStation","memo","id","viewBox","refY","d","fill","colorInterpolationFilters","filterUnits","width","height","operator","in","radius","result","in2","props","info_panel_type","svgWidth","stn_list","middle","runin","terminal","original","nextNames","name","prevNames","nextBranchLineDy","split","prevBranchLineDy","BranchLine","TerminalStation","mode","Line","textAnchor","CurrentText","NextStn","PrevStn","theme","coline","textProps","l","anchor","r","colineStns","values","nextColineColorFrom","nextColineColor","co","stroke","strokeWidth","markerEnd","undefined","isEnd","nextColineMode","every","nextColor","nextOrPassStnIds","isColineBranch","isInColineBranch","nextLineStretch","passLineStretch","LINE_BRANCH_Y","dotToPos","dot","dotsToPath","dots","at","nextDots","prevDots","stns","some","LINE_WIDTH","className","fontSize","dy","NextText","nextName","others","i","array","prevHintDy","nextBranchTextDy","dx","nextHintDy"],"sourceRoot":""}